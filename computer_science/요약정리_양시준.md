# 밑바닥부터 만드는 컴퓨팅 시스템(nand2tetris) 요약 정리

### 이 글은 무엇을 다루는가?

지금까지 nand2tetris 프로젝트를 하면서 하나에서 두 챕터마다 책의 내용을 요약하고 정리했다.

다만 책을 다 읽고 나서 다시 정리한 내용을 흝어보았고 단점 하나를 찾았는데, 요약본에선 각 챕터가 어떻게 연결되는지 잘 보이지 않았다.

그래서 요약본을 보완하기 위해 이 글에서는 "각 챕터가 어떻게 연결되는지"를 정리해보고자 한다.

## 총 정리

- 1장에서 기본적인 Chip을 구현한다.
- 2장에선 더 복잡한 Chip을 구현하고, 3장에선 시간 정보를 포함하는 Chip을 구현한다.
- 4장에선 앞으로 사용한 기계어를 정의한다.
- 5장에선 기계어를 처리할 수 있는 컴퓨터를 구현한다. (이 부분을 잘 이해해야 이후 장을 쉽게 이해할 수 있음)
- 6장에선 어셈블리어를 기계어로 변환하는 어셈블러를 만든다.
- 7~8장은 VM 언어의 정의와 변환기(VM -> 어셈블러)를 만든다.
- 9장은 Jack 언어를 정의하고, 10~11장은 변환기(Jack -> VM)을 만든다.
- 12장은 하드웨어 부분을 사용하기 쉽게 하는 Jack API(겸 OS)를 만든다.

개인적으로 느낀 건, Jack 구현이나 책에서 다루는 정의를 외우는 것보다.

고수준 언어가 어떤 과정을 거쳐 변환되는지?, 컴퓨터는 어떤 식으로 동작하는지? 고수준 언어의 if-else, function은 저수준 언어에서 어떻게 동작하는지? 등의 추상적인(?) 개념을 이해하는게 더 중요한 것 같다.

## 1장: Boolean Logic - 불 논리

컴퓨터는 0과 1만을 사용하는 수 체계인 이진법을 사용한다.

아날로그 신호를 쉽게 처리할 수 있기 때문이다. (= 하드웨어 설계의 복잡성 감소)    
(아날로그 신호를 3가지 이상의 상태(N진법)로도 표현할 수 있겠지만, 그런 중간 값을 처리할 수 있는 부품의 가성비가 On/Off의 기기에 비해서 좋지 않다.)

불 대수(Boolean Algebra)는 논리학에서 참 거짓을 나타내는 데 사용되고, 하드웨어 개발에도 사용된다.    
(대수: 일련의 연산들이 주어진 집합)

게이트(Gate): 불 함수를 하드웨어로 구현한 물리적 장치. 칩(chip)이라고도 부른다.

이러한 Chip들의 집합으로 여러 이진 연산을 처리하는 더 복잡한 칩을 만들 수 있다.

**요약: 2진법을 기반으로 한 Chip을 구현한다.**

## 2장: Boolean Arithmetic - 불 연산

범용 컴퓨터 시스템은 여러 산술 연산(부호 + 사칙연산)을 지원해야 한다.

수학에서 숫자는 무한하지만 컴퓨터에서는 유한한 고정 단어 크기(word size)를 사용하므로 무한하지 않다.    
(32bit, 64bit 컴퓨터라고 부를 때, 이 비트 수가 word size를 나타낸다.)

고정 단어 크기보다 더 큰 범위의 값을 사용하기 위해 고수준 언어는 추상화 기법을 지원한다.

2진수의 덧셈은 가산기(종류가 많음), 뻴셈은 2의 보수와 덧셈을 사용해서 구현할 수 있다.

컴퓨터는 모든 연산을 처리하는 CPU(중앙 처리 장치, Central Processing Unit)에서 ALU(산술 논리 장치, Arithmetic Logic Unit) Chip을 사용해 모든 산술 및 논리 연산을
처리한다.

**요약: Chip의 집합으로 산술 및 논리 연산을 수행하는 ALU를 만든다.**

## 3장: Memory - 메모리

컴퓨터가 더 반복적이고 큰 규모의 작업을 하기 위해서 중간 작업을 기억해야만 한다.        
따라서 이전 시간의 비트 정보를 저장하는 Chip이 필요한데, 이를 플립플롭이라고 부른다.

실제 시간은 무한하게 나눌 수 있다.     
하지만 컴퓨터의 자원은 제한적이므로, 컴퓨터는 이산적인 시간(Discrete time)을 가진다.

한 사이클이 이루어지는 동안, 내부적으로 전압이 변화하고 계산이 이루어진다. 하지만 이 중간 상태는 필요하지 않고, 결과만 필요하므로 중간 변화는 무시된다.      
이를 통해 이산적인 시간을 가질 수 있다.

**요약: 이전 시간(사이클)의 값을 기억하는 플립플롭을 사용해서 값을 저장하는 레지스터, 레지스터의 집합인 RAM, 카운터 등의 Chip을 구현할 수 있다.**

## 4장: Machine Language - 기계어

컴퓨터가 이해하는 언어를 기계어라고 한다.

기계어를 특정 문자(기호)로 변환하여 사람이 쉽게 읽고 쓸 수 있는 언어를 어셈블리어(assembly language)라고 한다.

이런 기계어와 어셈블리어(저수준 언어)는 하드웨어(CPU)와 밀접한 연관이 있어서, CPU의 종류가 달라지면 언어도 달라진다.

이런 기계어는 산술 및 논리 연산, 메모리 접근, 흐름 제어(goto, label), 기호(하드웨어의 메모리 주소를 의존하지 않음, goto문 같은거 수행할 때)을 지원한다.

**요약: CPU가 이해하는 기계어와 인간에게 친숙하게 변환한 기계어인 어셈블리어를 정의한다.**

## 5장: Computer Architecture - 컴퓨터 구조

(5장 내용 관련해서는 혼자 공부하는 컴퓨터 시스템, 운영체제 책을 조금 참고)

컴퓨터가 무엇인지는 생략하겠다. 5장 요약 정리를 보자.

#### 컴퓨터가 어떻게 동작하는가?

아래 내용은 매 사이클마다 반복된다.

1. 명령 수행 요청: CPU에게 프로그램 실행 요청이나 인터럽트(중단 요청)이 전송된다. 프로그램 실행 요청의 경우 아래 순서를 따라 진행되고, 인터럽트의 경우 현재 진행을 잠시 중지하고 인터럽트 서비스 루틴(
   Interrupt Service Routine, ISR)으로 이동하여 연산을 처리한다.
2. CPU의 작업 수행: CPU는 받은 명령에 따라 다양한 작업을 수행합니다. 이에는 산술/논리 연산, 메모리 접근(읽기/쓰기), 레지스터 간의 데이터 전송 등이 포함됩니다. 명령어는 CPU 내부의 명령어
   레지스터(Instruction Register)에 저장되어 해독되고 실행됩니다.
3. 상태 변경: CPU의 작업으로 인해 메모리나 레지스터 등의 상태가 변경된다. 연산 결과의 저장, 레지스터 간의 데이터 이동 등이 포함된다.
4. 다음 명령 실행 준비: Program Counter는 다음에 실행할 명령어의 주소를 가리키도록 업데이트된다. 그럼 CPU는 다음 명령어를 실행할 준비가 된다.

(단, nand2tetris에서는 인터럽트는 고려하지 않는다.)

**요약: 4장에서 정의한 기게어의 명세에 맞게, RAM, CPU, ROM 등의 Chip을 사용해서 컴퓨터를 만든다.**

## 6장: Assembler - 어셈블러

고수준 언어를 사용해서 어셈블러를 만드는데, 그럼 처음에 이 고수준 언어는 어떻게 만들어졌을까?    
이는 https://ko.wikipedia.org/wiki/%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9_(%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC)
이라는 과정을 통해 가능해진다.

**요약: 어셈블리어를 기계어로 변환하는 어셈블러를 만든다.**

## 7~8장: Virtual Machine - 가상 머신

가상머신은 고수준 언어와 대상 기계어의 영역을 분리하는 중간 인터페이스이다.

주로 스택 기반의 가상머신을 많이 사용하고, nand2tetris에서도 스택 기반의 가상머신을 구현한다.

VM언어 자체가 어셈블리어에 가까운 언어라서 구현을 이해하는게 크게 어렵지 않다.

**요약: 가상머신을 기계어로 변환하는 변환기를 고급 언어로 구현한다.**

## 9장: High-Leval Language - 고수준 언어

**요약: nand2tetris에서 정의한 Jack 언어를 통해 간단한 프로젝트를 만든다.**

## 10~11장: Compiler - 컴파일러

고수준 언어를 VM 언어로 변환하는 컴파일러를 만든다.

VM 언어는 상대적으로 저수준 언어에 가까워서 구현 난이도가 높다.

파서, 심볼 테이블, 고수준 기능(if-else, function)을 저수준 기능으로 변환하는 과정을 구현하는게 어렵다.

**요약: Jack 언어를 VM 코드로 변환하는 변환기를 구현한다.**

## 12장: Operating System - 운영 체제

운영체제는 "하드웨어에 종속된 저수준 서비스를 프로그래머에게 친숙한 소프트웨어 서비스로 캡슐화해주는 프로그램"이라고 볼 수 있다.

현대 운영체제는 멀티 프로세스, 가상 메모리 & 메모리 페이징, 파일 시스템 등 여러 기능을 제공한다. 하지만 이 역시 하드웨어에 대한 추상화로 볼 수 있다.

(운영체제 가장 쉬운 3가지 에서는 가상화, 병행성, 영속성에 대한 추상화를 제공한다고 표현하기도 한다.)

**요약: 하드웨어에 대한 추상화를 제공해주는 Jack API를 개발한다.**

