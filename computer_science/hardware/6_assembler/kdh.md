## assembler
어셈블러는 어셈블리어를 기계어로 변환해주는 프로그램이다.  
헷갈리면 안되는게 어셈블러는 assembler이고 어셈블리어는 assembly language 이다.  


## project
이번 장의 실습은 고급언어로 진행된다.(파이썬, 자바 등)  
~~실제로 맨처음에는 컴파일러는 당연히 이런 고급언어로 작성되지 않았을텐데, 이에 대해 맨처음에는 어떤식으로 컴파일했는지 알려주지 않아서 아쉽다.~~  
아래에서 이야기한다

이번 역시 HACK이라는 강의에서 만든(? 만든건지는 정확히 모르겠지만 강의에서만 쓰이는) 언어에 특화된 어셈블러이기에 설명할 것이 많지 않다.  
HACK언어의 구문으로는 3가지가 전부이다.  
- a insturction | syntax : @xxx, bin : 0xx...xx
- c instruction | syntax : dest=comp;jump, bin : 111ac1..6d1..3j1..3
- label | syntax ({label})

a는 간단하고, c는 전에 hack binary 표 보면서하면 되고 레이블이 조금 신경써줘야할 부분이다.  
label을 번역할때에는 문제가 있다.  
label은 (label)의 위치가 label에 할당되는 것인데, 아래와 같은 경우 label에 값이 할당되기도 전에 label이 등장할 수 있다.  
> @label  
> 0;jmp  
> ...  
> (label)

이런 경우 label을 번역하는 방법은 2가지가 있다.  
하나는 아직 값이 할당 되지 않은 label이 있다는 걸 기억해두는 것이고  
두번째는 좀더 쉬운 방법인데 번역을 2번하는 것이다.  
첫 번역에서 label만 먼저 번역해 label에 값을 할당해두는 것이다.  
그리고 이후에 전체를 번역하는 것이다.  
또한 이런식으로하면 @label이 레이블인지 변수인지도 쉽게 알 수 있다.  
값이 할당되지 않은 레이블이 있으면 해당 레이블은 레이블이 아니라 변수일테니  


## first assembler
강의의 마지막 영상인 perspective에서 이야기하는데 이렇게 이야기한다.  
> 프로그래머가 아닌 이 강의의 수강생들은 실제로 수작업으로 어셈블리어를 기계어로 번역했습니다.  
> 개념적으로 최초의 어셈블러도 같은 방식입니다.  
> 고수준의 언어로 어셈블러를 구현하고  
> 해당 코드를 어셈블리어로 다시 구현하면 됩니다.  
> 그리고 이작업은 한번만 이루어지면 이후에 추가로 다시 할 필요는 없습니다.

그냥 저수준언어로 알아서 잘 구현했다는 말인거 같다.  
근데 어짜피 한번만 완성하면 끝이므로 현재로썬 크게 신경쓸필요가 없다고 하는 듯  
이름이 어셈블러, 컴파일러라 그러지 원래 맨처음에는 개발도 천공카드로 직접 어떤 물리적인 작업을 통해서 헀을테니  
지금으로 치면 그냥 하나의 자동화 작업이라고 생각해도 될듯

## note
과제에 Max.asm와 Rect.asm관련 오류가 있음 아래글 참조
https://www.coursera.org/learn/build-a-computer/discussions/forums/aIwKUSj3EeaZ8Apto8QB_w/threads/cvmp0X7hEe6QMRKEnYEYdQ