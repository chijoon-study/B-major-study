# Memory - 메모리

## 읽기 전에

책 [61.p에 번역 오류](https://github.com/chijoon-study/cs-study/issues/8#issuecomment-1945267243) 있음. independent를 의존성 이라고 번역함. 독립적인, 독립성 등의 의미가 더 알맞다.

여러 칩을 같은 의미로 설명하는데, 찾아보니까 약간은 의미가 다르거나 어떤 걸 중요하게 생각하느냐에 따라 차이가 있는 듯 하다. 단 핵심적인 부분(시간 독립적인가?)은 같음.

책에서 DFF를 구현하지 않고 내부 구조도 말하지 않는데, Hack HDL 툴의 한계 때문이라고 한다.   
궁금하면 추가적으로 찾아보고 정리해야 할 듯.
> (생략)... 조합 게이트 사이에 피드백 루프를 만들어야 하기 때문에 이 책의 하드웨어 시뮬레이터로는 모델링하기 불가능하다.

이전해도 말한 것 같지만, 실습에서 사용하는 기반 칩은 내가 구현하지 않고, 미리 제공 된 걸 사용한다. 내가 만드는 것 최적화가 안 되어 있고 재귀적이라 느리기 때문.

현대의 컴퓨터는 꼭 플립플롭을 사용하지 않기도 하고, 구현 방식도 책에서 설명한 것과 많이 다르다.(최적화 되어있다.) 이는 복잡성을 줄이기 위한 것이고, 이런 구현을 제외하고 명세는 거의 실제와 비슷하게 표준적으로 작성되었다.

## 칩의 종류

#### 조합 칩(combinational chip) or 시간 독립 칩(time-independent chip)

$out[t] = function(in[t])$

현재 클록 주기(사이클)에 발생한 변화에만 응답하는 칩을 말한다.

책 1,2장에서 개발한 칩들이 여기 해당된다.

#### 순차 칩(sequential chip) or 클록 칩(clocked chip)

$out[t] = function(in[t-1])$

이전 시간 단위에서 발생한 변화와 현재 시간 단위의 변화에 응답하도록 설계된 칩을 말한다.

이러한 칩을 구현하기 위해서 하나의 비트를 저장하고, 비트를 t-1에서 t로 옯길 수 있는 무언가가 필요한데, 이 기능을 구현한 것을 플립 플롭이라고 한다.   
(여러 플립플롭이 있지만, 책에서는 Clocked Data Flip Flop을 기준으로 설명한다.)

모든 순차 칩은 플립플롭을 사용해서 만들어진다.

## 컴퓨터의 시간

### 시간의 필요성

컴퓨터가 더 반복적인, 큰 규모의 작업을 하기 위해서 중간 작업 같은 무언가를 기억해야만 한다.   

이를 위해서 컴퓨터에는 "시간" 개념이 필요하고, 시간에 따라 "상태"(State)를 기억하는 도구가 필요하다.

### 컴퓨터에서 시간의 의미
실제 물리적인(physical) 시간은 연속적(continuous)이다.  
시간은 무한하게 나눌 수 있다. 

하지만 컴퓨터의 자원은 제한적이므로, 컴퓨터는 이산적인 시간(Discrete time)을 가진다. ('이산적인'의 의미는 아래에서 다룬다.)

#### 이산적 시간 개념의 특성

- 통신이나 계산중에 발생하는 시간 지연과 무적위성을 줄일 수 있다.
- 시스템 전체에서 여러 칩들의 연산을 동기화하는데 그 개념을 활용할 수 있다.

#### 시간의 논리적인 개념

클럭은 일종의 발전기(Oscillator)이다.  
일정한 속도로 0과 1 상태로 번갈아 가진다. (tic-toc이라고 표현하기도 한다.)  

tic의 시작과 toc의 종료 사이의 시간을 사이클(cycle)이라고 한다.

**사이클은 디지털의 최소 시간 단위로 취급한다.**

개념적으로 사이클이 시간의 최소 단위이므로, 사이클 사이에는 아무것도 변하지 않는다. 

이처럼 컴퓨터에선 시간이 단절되어 구분하기 때문에, 이산적인 시간을 가진다고 말한다.

#### 물리적인 구현

그러나 실제로(물리적으로) 클럭/사이클 개념을 어떻게 구현하는가?

![computer_time_layout](./ysj_files/computer_time_layout.png)

물리적으로 input(전압)은 천천히 변한다.   
하지만 한 사이클 내에 중간 변화를 마무리 할 수 있다면, 이러한 중간 변화(불일치)는 사이클이 마무리 된 시점의 결과에 영향을 주지 않는다.  
따라서 사이클 내의 변화는 무시된다.

이를 통해 이산적인 시간을 가질 수 있다.  
이러한 특징 때문에 사이클은 칩의 최대 지연 시간보다 (조금) 더 길게 설정된다.

## 칩(논리게이트) 명세

- #### 데이터 플립-플롭(data flip-flop, DFF)
    - 1비트 입력을 받아 DFF의 상태를 이 값으로 설정, 다음 주기에서 이 값을 출력한다. ($out(t) = in(t-1)$)
    - (책에서 다루는) 순차 칩 중 가장 기초적인 칩이다.
    - ![DFF_spec](./ysj_files/DFF_spec.png)
- #### 레지스터(register)
    - 새로운 값을 불러오라고(load를 1로) 지시하기 전까지, 값을 저장하고 출력한다.
    - load 비트가 설정되지 않으면 레지스터가 잠금 상태가 되며, 입력(input)값과 상관없이 현재 상태를 유지한다.
    - 책에선 1비트 레지스터, 16비트 레지스터를 구현한다.
    - ![register_spec](./ysj_files/register_spec.png)1비트 레시스터 그림
- #### RAM(random access memory)
    - n개의 레지스터 칩으로 구성된다.
    - 각 레지스터 칩에 특정 주소를 할당하고, 이 주소를 사용해 특정 레지스터를 선택하고 읽기/쓰기 작업을 수행한다.
    - 랜덤 접근 시간이 즉각적이고 RAM의 크기나 레지스터의 주소에 영향을 받지 않는다. (그렇게 구현해야 한다.)
    - load 비트가 0이면 읽기, 1이면 쓰기 연산을 수행한다.
    - ![RAM_spec](./ysj_files/RAM_spec.png)
- #### 카운터(counter)
    - 매 시간 단위마다 값을 1씩 증가시키는 칩이다.
    - 컴퓨터 아키텍처에서 PC(program counter)로 사용된다.
    - ![alt text](./ysj_files/counter_spec.png)


## 실습 메모
실습 중 메모한 것들 올림.

나중에 복습할 때 기억하기 좋으라고 적은거라 딱히 볼 필요는 없다.


메모리 구현
- Bit: 이름에 언더바 못써서 에러 난거만 빼면, 책에서 풀이 다 나와서 쉽게 품
- Register: 책에서 Bit 16개로 구현하라고 나와서 쉽게 품. 
- RAM8: 책 설명 봄 - 그림 그려서 해결
    - 주소 구하기 - DMux 
        - DMux 의 역할: 변경하려는 곳에 load 값 보내기
    - 값 보내기 - Mux
        - 주소 받아서 특정 레지스터 값만 반환
    - load가 0이면 in이 있어도 영향을 안주니까 모든 레지스터에 다 보내도 됨, load 1 이면 DMux 통해서 변경하려는 주소에만 값 주니까 ㄱㅊ
    - 처음 DMux에는 16비트 버스가 없어서 고민했는데, 그림 그려서 대충 감 잡으니까 이해함, DMux, Mux가 결국 둘 다 있어야 하고 DMux가 load 다루는게 더 효율적인 것 같고, 책에서도 그걸 의도하는듯?
- RAM64~16K: 비슷하게 풀면 됨,  일부 주소는 하위 구현에 맞기고 나머지는 RAM8 구현하는거처럼 DMux, Mux 써서 풀면 됨
- Counter(PC): 구성 요소는 책에서 나옴, 어려워서 고민 좀 함 
    - 일단 기능 위주로 정리
        - 1. 값 저장 - 레지스터
        - 2. 카운트 증가 - load가 아니면 Inc16 결과를 값으로 저장
        - 3. Reset: 그냥 입력되는 값을 0000으로 하면 되는거 아님?(input이라 약간 다른기)
        - 4. 여러 입력 제어 - Mux
    - 잘 생각이 안나서 그림 그리면서 기능 따로 만들고 합치는거 생각하기
        - 일단 load, reset, inc는 3중 하나만 사용하는게 API 규칙임
        - 근데, 멀티플럭서를 왜 쓸까? - 레지스터처럼  input이 여러게일 듯
            - load는 레지스터랑 연결되니까, reset, inc인가?
            - 근데 다 값이 수정됨, 3개 입력 받아야 하니까 mux8way인듯
            - 이쯤에서 이해가서 그림 그려서 정리하고 해결
            - 하려고 했는데, 구현이 잘 안됨, mux가 8개 input중 3개만 쓰는것도 그래서 그냥 mux 조합해서 쓰기로 변경
            - ![draw_pc](./ysj_files/draw_pc.png) 그림 (3번째 mux true에서 false로 바꾸기)

