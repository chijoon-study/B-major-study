# Compiler

### 시작하기 전에

- 성능을 고려하지 않고 제한적이다. 
  - 타입, 형변환, 상속, 접근제어자, 연산자 우선순위 등 여러 기능이 제공되지 않는다.
  - 파싱에서 실제론 중요한 상향식에 대한 설명이나 파싱 알고리즘, 형식언어이론 등을 다루지 않는다.
  - 오류 진단 및 보고에 대한 구현되 생략되었다.
  - 그 외 여러 이론에 대한 설명이 부족하다. (책의 역할을 생각해보면 당연한거긴 함. 상용 프로그램 개발이 아니니까.)
- 이 강의에서 구현하는 컴파일러는 VM컴파일러다. 실제로 매모리를 다루거나 하지 않는 추상화 된 컴파일러이다. 다만 기본적인 구조는 다른 컴파일러와 다르지 않다.

- 실제로 파싱 기능은 여러 컴파일러들도 직접 만들지 않고, LEX나 YACC 같은 구문 분석 프로그램을 통해 구현한다. (아마 실무에서도 경우에 따라 쓰기도 하는듯?)

## Compiler

컴파일을 수행하는 프로그램을 컴파일러라고 부른다.

컴파일은 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 것을 의미한다. (ex: javac는 `.java` -> `.class`)

컴파일은 두 단계로 구성된다.

- 구문 분석(syntax analysis)
- 코드 생성(code generation)

(추가)    
실제 현대 컴파일러는 Frontend, Middleend, Backend로 구분된다. 주로 다음과 같은 일을 수행:
- Frontend: 구분 분석
- Middleend: 최적화
- Backend: 코드 생성

하드웨어 독립적인 중간 언어를 사용했을 떄에는 여러 장점이 있다.
- 플랫폼 호환성: 동일한 중간 코드를 여러 플랫폼에서 실행할 수 있다. 상대적으로 저수준에 더 가까운 중간 언어를 기계어로 번역하기는게 쉽다.
- 컴파일러 개발 단순화: 컴파일러가 하드웨어 종속적이지 않으므로 더 빠르게 개발할 수 있다.
- 다양한 언어 지원: 프로그래밍 언어 -> 중간 언어 만 지원하면 다양한 언어를 같은 실행 환경에서 실행할 수 있다. (ex: LLVM, JVM)

### 구문 분석

구문 분석은 두 단계로 나뉘어진다.

- 토큰화(tokenizing)
  - 텍스트 파일에 저장된 문자열을 언어 어휘로서 정의된 "**토큰**"들로 분류하는 것.
    - 불필요한 주석이나 들여쓰기를 제외하고 의미있는 토큰만 남긴다.
    - 이러한 토큰들의 집합을 어휘(lexicon)이라고 부른다.
    - 프로그래밍 언어의 각 문법은 하나 이상의 토큰으로 구성된다. 문법은 메타 언어(meta-language)를 사용해 정의된다. 
  - 어휘 분석(lexical analysis), 스캐닝(scanning)으로 불리기도 한다.
- 파싱(parsing)
  - 토큰들을 의미가 있고 구조화된 명령문들로 분석하는 것.
  - 문법을 바탕으로 토큰을 분석힌다. 올바른 토큰의 집합이더라도, 문법에 맞지 않으면 아무 의미도 없다. 
    - 영어로 예를 들면 red drive a he는 유효한 토큰의 집합이지만, 문법이 맞지 않고, 아무 의미도 없다.
    - "문법은 본질적으로 재귀적이다." (책에서 나온 문장인데, 좀 보기 좋아서 가져옴) 
    - 파싱이 이루어지면 파스 트리(parse tree, 또는 유도(derivation) 트리) 형태로 표한할 수 있다.
  - [LL 파서](https://en.wikipedia.org/wiki/LL_parser)는 좌측유도(Leftmost derivation) 방식으로 동작한다.
    - lookahead에 최대 k개의 토큰(token)을 사용한다면, 그 파서는 LL(k) 파서라고 부른다. 
    - 백트레킹 없이 하양식(top-down) 재귀 알고리즘으로 파싱할 수 있는 문법을 LL grammar라고 부른다.
    - (핵심적인 내용은 아닌데, 그냥 내가 정리하고 싶었음)

#### 파싱 부연 설명
![parse_tree](./ysj_files/parse_tree.png)

> 문법은 본질적으로 재귀적이다.

에 대한 구체적인 설명과 파싱이 재귀적으로 이루어지는 과정 설명

위 이미지를 예시로 들면 if 문은 `if` `(` `expression` 등으로 구성된다.    
이 중 `expression`은 표현식 문으로, `term`, `op` 등을 가진다.   
`term` 또한 여러 토큰을 가진다.     

if 문을 해결하기 위해서, `expression`를, `expression`를 위해서 `term`을 ...    
이렇게 재귀가 발생한다.

(문법에서 나오는 `?`, `*`는 메타 언어로 표현한건데, regex 생각하면 편할듯.)

#### Jack 언어의 경우

- Jack 언어는 특정 문법을 제외한 대다수가 LL(1)이다. 이는 구현의 편의를 위해 의도적으로 설계된 것이다.
- 중간 테스트를 위해 XML으로 결과를 출력한다.

### 코드 생성

분석된 의미(semantics)를 기반으로 목적 언어를 생성한다. (시적 언어 -> 목적 언어)

고수준의 현대 프로그래밍 언어를 저수준으로 번역하는 것은 꽤나 어려운 일이다. (그게 상대적으로 더 추상화 묀 가상머신 언어로 번역하는 것이더라도.)

#### 주요 내용

- 변수 처리
  - 변수 처리의 조건
    - 변수를 실제 메모리에 관리해야 한다.
    - 변수마다 메모리 크기와 생명주기가 다르다. (static, local 등)
  - 기호(symbol) 테이블을 사용해서 위 조건을 해결항 수 있다.
    - 범위 수준(or scope)에 따라 별개의 기호 테이블이 존재한다.
- 표현식 처리
  - 일반적인 고주순 언어는 중위표현식을 사용한다. 이를 저수준 언어가 주로 다루는 후위표현식으로 변경해야 한다.
- 문자열 처리: 많은 프로그램에서 자주 사용되므로 특화된 기능을 제공하기도 함. 
- 명령문 처리: 의도한대로 구현해야 한다. (Jack에서 어떻게 만드는지를 주로 다룸)
- 객체 처리
  - 기호 테이블에선 실제 값 대신, 실제 주소의 포인터(참조) 값을 저장한다.
  - 객체를 생성하면서 Heap 영역에도 메모리 공간이 할당된다.
  - 실제로 객체가 생성되는건 런타임 시점에 이루어진다. (기호 테이블에 정의 되는 것 자체는 컴파일 시점)
- 메서드 처리
  - 이건 이해를 못하겠네, this, that이 정확히 뭐하는거야?
    - 이 부분 객체도 관련있을듯.
- 배열 처리
  - 여기도 that을 사용하긴 함. (강의 보고 설명 추가)
  - 객체와 비슷하게 포인터를 사용하여 구현한다.


#### Jack 언어의 경우

- Jack 컴파일러의 목적 언어인 VM 언어는 메모리를 직접적으로 관리하지 않는다. 따라서 변수 관련해서 심볼테이블 관리만 하면 된다.

## 실습

코드에 설명함 `'''` 주석 사용한 부분이 명세, `#`는 코드 설명으로 보면 됨

- 메모
  - advance()는 한 줄 처음부터 읽다가 다음 줄이 토큰이네? 지금까지 읽은거로 토큰 반환하고 시작점 설정
    - 한 줄에 여러 토큰이 있을 수 있음
    - 정규식 사용하면 되는거 아닌가?
  - 디렉토리 or 파일을 지원해야 함
  - XML은 들여쓰기 없어도 되니까 그냥 들여쓰기 없이 작성할거임. 사실 있는게 좋기는 한데...
  - 구문 분석기 테스트에 사용되는 파일은 실제로는 별 의미가 없는 코드도 있음. 이는 분석이 잘 동작하는지 확인하기 좋기 때문임.
  - 일부 expressions은 callxxx를 지원하지 않고, 다른 callxxx와 통합된 것도 있음.

## 책 읽고 생각나는거 아무거나 메모

- 자바에서 FE는 javac와 그 외 프로그램이고, BE는 JRE로 볼 수 있을 것 같다.
- Jack에서는 프로그램을 실행하기위해 하나의 .asm으로 변환하는데, 자바는 JVM이 동작하면서 내부 인터프리터가 처리한다.
- Jack이나 자바나 linking 과정이 late(or lazy)하게 발생한다.
  - 외부 의존 파일 없이도 VM언어는 개별적인 파일로 존재하는데, 자바에서는 plain.jar로 사용해서 빠르게 CICD를 하거나 할 때 사용된다.
  - 실제 기계어로 번역할 때 쯤에야 특정 클래스가 의존하는 외부 클래스가 필요하다는거. JVM 관련 글 들을때 이해가 안 갔는데, 이제 어느정도 이해됨
- 2단계 컴파일이 확실히 편하긴 한듯
  - 언어 만드는 입장에서 자바나 코틀린 그루비처럼 중간 언어를 사용해서 JVM만 지원하면 다 잘 실행되는게 꽤나 큰 장점일듯.
    - BE를 만들지 않아도 되고, 대신 자유도는 조금 떨어지겠지만.
  - 근데 굳이 가상머신이 필요한 방식은 아닌거 같은데, Jack 언어도 가상머신 없이 동작하고.
    - 그런 점에선 Jack은 LLVM에 더 가까우려나
  - 물론 책에서 구현을 쉽게 할 수 만든거지만, FE 만드는 입장에서 하드웨어 메모리를 관리할 필요 없고, 그 외 여러 면에서 단순하게 구현 가능한게 좋은듯.
- 이런 느낌으로 구현하는거면 나도 JVM을 만들어볼 수 있지 않을까?
  - 물론 진짜 JVM 그 표준이나 테스트에 맞추눈게 아니라, 바이트코드 읽고 처리하는거 정도는 만들 수 있을거 같은데.
  - 파이썬 사용하면 꽤나 쉬울거 같기도 하고...