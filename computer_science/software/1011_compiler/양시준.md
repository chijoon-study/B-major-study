# Compiler

### 시작하기 전에

- 성능을 고려하지 않고 제한적이다.
    - 타입, 형변환, 상속, 접근제어자, 연산자 우선순위 등 여러 기능이 제공되지 않는다.
    - 파싱에서 실제론 중요한 상향식에 대한 설명이나 파싱 알고리즘, 형식언어이론 등을 다루지 않는다.
    - 오류 진단 및 보고에 대한 구현되 생략되었다.
    - 그 외 여러 이론에 대한 설명이 부족하다. (책의 역할을 생각해보면 당연한거긴 함. 상용 프로그램 개발이 아니니까.)
    - 조금 별개의 이야기지만, 성능은 컴파일러 자체의 성능보다 컴파일러가 생성하는 목표 언어가 얼마나 효율적인지가 더 중요하다.
- 이 강의에서 구현하는 컴파일러는 VM컴파일러다. 실제로 매모리를 다루거나 하지 않는 추상화 된 컴파일러이다. 다만 기본적인 구조는 다른 컴파일러와 다르지 않다.

- 실제로 파싱 기능은 여러 컴파일러들도 직접 만들지 않고, LEX나 YACC 같은 구문 분석 프로그램을 통해 구현한다. 

## Compiler

컴파일을 수행하는 프로그램을 컴파일러라고 부른다.

컴파일은 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 것을 의미한다. (ex: javac는 `.java` -> `.class`)

컴파일은 두 단계로 구성된다.

- 구문 분석(syntax analysis)
- 코드 생성(code generation)

(추가)    
실제 현대 컴파일러는 Frontend, Middleend, Backend로 구분된다. 주로 다음과 같은 일을 수행한다.

- Frontend: 구분 분석
- Middleend: 최적화
- Backend: 코드 생성

하드웨어 독립적인 중간 언어를 사용했을 떄에는 여러 장점이 있다.

- 플랫폼 호환성: 동일한 중간 코드를 여러 플랫폼에서 실행할 수 있다. 상대적으로 저수준에 더 가까운 중간 언어를 기계어로 번역하기는게 쉽다.
- 컴파일러 개발 단순화: 컴파일러가 하드웨어 종속적이지 않으므로 더 빠르게 개발할 수 있다.
- 다양한 언어 지원: 프로그래밍 언어 -> 중간 언어 만 지원하면 다양한 언어를 같은 실행 환경에서 실행할 수 있다. (ex: LLVM, JVM)

### 구문 분석

구문 분석은 두 단계로 나뉘어진다.

- 토큰화(tokenizing)
    - 텍스트 파일에 저장된 문자열을 언어 어휘로서 정의된 "**토큰**"들로 분류하는 것.
        - 불필요한 주석이나 들여쓰기를 제외하고 의미있는 토큰만 남긴다.
        - 이러한 토큰들의 집합을 어휘(lexicon)이라고 부른다.
        - 프로그래밍 언어의 각 문법은 하나 이상의 토큰으로 구성된다. 문법은 메타 언어(meta-language)를 사용해 정의된다.
    - 어휘 분석(lexical analysis), 스캐닝(scanning)으로 불리기도 한다.
- 파싱(parsing)
    - 토큰들을 의미가 있고 구조화된 명령문들로 분석하는 것.
    - 문법을 바탕으로 토큰을 분석힌다. 올바른 토큰의 집합이더라도, 문법에 맞지 않으면 아무 의미도 없다.
        - 영어로 예를 들면 red drive a he는 유효한 토큰의 집합이지만, 문법이 맞지 않고, 아무 의미도 없다.
        - "문법은 본질적으로 재귀적이다." (책에서 나온 문장인데, 좀 보기 좋아서 가져옴)
        - 파싱이 이루어지면 파스 트리(parse tree, 또는 유도(derivation) 트리) 형태로 표한할 수 있다.
    - [LL 파서](https://en.wikipedia.org/wiki/LL_parser)는 좌측유도(Leftmost derivation) 방식으로 동작한다.
        - lookahead에 최대 k개의 토큰(token)을 사용한다면, 그 파서는 LL(k) 파서라고 부른다.
        - 백트레킹 없이 하양식(top-down) 재귀 알고리즘으로 파싱할 수 있는 문법을 LL grammar라고 부른다.
        - (핵심적인 내용은 아닌데, 그냥 내가 정리하고 싶었음)

#### 파싱 추가 설명

![parse_tree](./ysj_files/parse_tree.png)

> 문법은 본질적으로 재귀적이다.

에 대한 구체적인 설명과 파싱이 재귀적으로 이루어지는 과정 설명

위 이미지를 예시로 들면 if 문은 `if` `(` `expression` 등으로 구성된다.    
이 중 `expression`은 표현식 문으로, `term`, `op` 등을 가진다.   
`term` 또한 여러 토큰을 가진다.

if 문을 해결하기 위해서, `expression`를, `expression`를 위해서 `term`을 ...    
이렇게 재귀가 발생한다.

(문법에서 나오는 `?`, `*`는 메타 언어로 표현한건데, regex 생각하면 편할듯.)

#### Jack 언어의 경우

- Jack 언어는 특정 문법을 제외한 대다수가 LL(1)이다. 이는 구현의 편의를 위해 의도적으로 설계된 것이다.
- 중간 테스트를 위해 XML으로 결과를 출력한다.

### 코드 생성

분석된 의미(semantics)를 기반으로 목적 언어를 생성한다. (시적 언어 -> 목적 언어)

고수준의 현대 프로그래밍 언어를 저수준으로 번역하는 것은 꽤나 어려운 일이다. (그게 상대적으로 더 추상화 묀 가상머신 언어로 번역하는 것이더라도.)

#### 주요 내용

각 언어의 주요 특징:

- 고수준 언어: 객체와 배열을 다룬다. 다양한 연산을 제공한다.
- 중간 언어: 제한된 메모리 세그먼트와 제한된 연산을 다룬다. (if-else, while 등의 기능이 없다.)
- 저수준 언어: 메모리를 직접적으로 다룬다.

우리는 고수준 언어 -> 중간 언어가 목적이다.

고수준의 다양한 연산을 상대적으로 저수준인 제한된 연산으로 처리할 수 있어야 한다.

- 변수 처리
    - 변수 처리의 조건
        - 변수를 실제 메모리에 관리해야 한다.
        - 변수를 식별하고, 변수의 정보(타입, 종류(인수, 지역 변수, 정적 변수 등))를 확인할 수 있어야 한다.
        - 변수마다 메모리 크기와 생명주기가 다르다. (static, local 등)
    - 기호(symbol) 테이블을 사용해서 위 조건을 해결할 수 있다.
        - 범위 수준(or scope)에 따라 별개의 기호 테이블이 존재한다.
        - 변수의 정보를 저장하고 찾을 수 있다.
        - 서브루틴(메서드)의 경우, 심볼 테이블에 임시적으로 this를 꼭 가지고 있다.
        - LinkedList를 사용해서 다양한 범위(scope)의 심볼 테이블을 제공할 수 있다.
- 표현식 처리
    - 일반적인 고주순 언어는 중위표현식을 사용한다. 이를 저수준 언어가 주로 다루는 후위표현식으로 변경해야 한다.
        - 후위표현식은 스택을 사용해서 쉽게 구현할 수 있기 때문이다. 스택 기반의 VM에 친화적이기도 하다.
    - 파스 트리를 분석해서 표현식을 만든다.
        - 트리이므로 dfs를 사용해서 코드를 생성할 수 있으나, 책에서는 Jack에 특회되고 더 단순한 방법을 사용한다.
- 문자열 처리: 많은 프로그램에서 자주 사용되므로 특화된 기능을 제공하기도 한다. 이 책에서는 하나의 사용 방법만 제공한다.
- 명령문 처리
    - if-else: if와 label, goto 기능을 사용해서 분기 기능을 구현할 수 있다. (저수준의 if는 더 제한적이다. 조건의 결과를 만족하면 goto 정도의 기능)
    - while: if-else와 비슷한 방식으로 if, label, goto를 사용해서 구현한다.
    - return: 결과를 스택에 push하고 return VM 코드를 실행한다.
    - let: 기호 테이블에서 변수를 가져와 해당 변수를 수정한다.
    - do: 서브루틴을 호출하고 결과를 사용하지 않고 pop한다.
- 객체 처리
    - 메모리의 Stack 영역에선 실제 값 대신, 실제 주소의 포인터를 사용해 주소(참조)를 저장한다.
    - 객체를 생성하면서 Heap 영역에도 메모리 공간이 할당된다.
        - 포인터는 Heap 영역의 객체 시작 주소를 참조한다. Heap 영역은 객체를 정의하는 메모리 풀로써 사용된다.
        - Jack에서는 생성자 호출 시 메모리 공간을 할당하고, 값을 초기화 한 후에 this를 반환한다.
    - 실제로 객체가 생성되는건 런타임 시점에 이루어진다. (기호 테이블에 정의 되는 것 자체는 컴파일 시점)
    - Jack의 메모리 세그먼트 구조 - (다른 곳에서 설명하는 메모리 구조(code, data, heap, stack)와 다른 설명임)
        - 책에서 명시적으로 설명하지는 않지만, 내가 구조를 이해하는데 도움이 되서 적었다.
        - segment: 연산에 필요한 현재 사용중인 값의 주소를 저장하는 영역 (ex: SP, LCL, ARG 등)
        - stack: local 및 argument variables 등을 저장하는 영역
        - heap: 객체외 배열을 저장하는 영역
- 메서드 처리
    - 내부 객체의 경우, 많은 언어에서 this를 생략해서 사용할 수 있도록 해준다. (this.x())
    - 메서드는 함수와 달리 주어진 객체에서 동작하는 서브루틴이므로 호출 시 어떤 인스턴스의 메서드인지 확인(초기화)하는 과정이 필요하다.
        - 메서드의 인자는 (주로) 암시적으로라도 this를 받고, 이를 사용해서 인스턴스의 상태에 접근할 수 있다.
    - void는 값을 고수준에선 값을 반환하지 않지만, 저수준에선 (최소한 Jack에선) 값을 반환하지만 caller에서 사용하지 않고 버리는 것이다.
- 배열 처리
    - 객체와 비슷하게 생성되고 Heap에 저장된다. Stack에선 주소를 저장한다.
    - this: VM에서 현재 객체(obeject)를 표현하기 위한 값
    - that: VM에서 현재 배열(array)를 표현하기 위한 값

#### Jack 언어의 경우

- Jack 컴파일러의 목적 언어인 VM 언어는 메모리를 직접적으로 관리하지 않는다. 따라서 변수 관련해서 심볼테이블 관리만 하면 된다.

## 실습

작성일 기준 2일 안으로 끝까지 마무리하고 싶은데, 너무 실습 진도가 느려서, 남들 코드를 많이 참고하였음.    
-> 그러다보니 구현이 꼬이고, 처음부터 다시 만들어야 해서 일단 다음 장으로 넘어갔는데, 기존 코드 참고해서 새로 만들기    
-> 기존 코드는 Seven 테스트까지는 통과하는 상황

## 책 읽고 생각나는거 아무거나 메모

- 자바에서 FE는 javac와 그 외 프로그램이고, BE는 JRE로 볼 수 있을 것 같다.
- Jack에서는 프로그램을 실행하기위해 하나의 .asm으로 변환하는데, 자바는 JVM이 동작하면서 내부 인터프리터가 처리한다.
- Jack이나 자바나 linking 과정이 late(or lazy)하게 발생한다.
    - 외부 의존 파일 없이도 VM언어는 개별적인 파일로 존재하는데, 자바에서는 plain.jar로 사용해서 빠르게 CICD를 하거나 할 때 사용된다.
    - 실제 기계어로 번역할 때 쯤에야 특정 클래스가 의존하는 외부 클래스가 필요하다는거. JVM 관련 글 들을때 이해가 안 갔는데, 이제 어느정도 이해됨
- 2단계 컴파일이 확실히 편하긴 한듯
    - 언어 만드는 입장에서 자바나 코틀린 그루비처럼 중간 언어를 사용해서 JVM만 지원하면 다 잘 실행되는게 꽤나 큰 장점일듯.
        - BE를 만들지 않아도 되고, 대신 자유도는 조금 떨어지겠지만.
    - 근데 굳이 가상머신이 필요한 방식은 아닌거 같은데, Jack 언어도 가상머신 없이 동작하고.
        - 그런 점에선 Jack은 LLVM에 더 가까우려나
    - 물론 책에서 구현을 쉽게 할 수 만든거지만, FE 만드는 입장에서 하드웨어 메모리를 관리할 필요 없고, 그 외 여러 면에서 단순하게 구현 가능한게 좋은듯.
- 이런 느낌으로 구현하는거면 나도 JVM을 만들어볼 수 있지 않을까?
    - 물론 진짜 JVM 그 표준이나 테스트에 맞추눈게 아니라, 바이트코드 읽고 처리하는거 정도는 만들 수 있을거 같은데.
    - 파이썬 사용하면 꽤나 쉬울거 같기도 하고...