# Virtual Machine

## 주의점

#### 1. 효율성 고려 X
다른 부분도 그렇듯, 이 책에서 다루는 가상머신에 대해선 효율성을 고려하지 않는다. 하지만 실제로는 정말 중요한 내용이다.   
> "실제로 Java, C#, Python의 VM 구현은 그동안 매우 극적으로 성능이 강화되고 정교해졌다."

#### 2. stack-based VM
스택 기반(stack-based)의 VM만 다룬다.  
대부분(Java, C#, Python 등)의 고수준 언어는 스택 기반의 VM를 사용한다. 

[레딧 글 - AskProggit: why are most VMs stack-based?](https://www.reddit.com/r/programming/comments/ap6wt/askproggit_why_are_most_vms_stackbased/)을 보면 레지스터 기반 VM은 스택 기반 VM보다 성능이 좋지만 기계어에 가깝고, 구현이 어렵다는 점 때문에 잘 사용하지 않는 것 같다.   
아예 사용하지 않는 건 아니다. Android의 Dalvik VM은 레지스터 기반 VM이다. (Dalvik VM은 Android 5.0 이상 버전부터 사용하지 않는다고 한다.)

#### 3. 7~8장 내용 포함
가상머신에 관한 내용은 7~8장으로 나누어 설명하는데, 이 글에선 두 장을 합쳐서 설명한다.

## 가상머신 패러다임

가상머신은 고수준 언어와 대상 기계어의 영역을 분리하는 중간 인터페이스이다. (추상화를 제공한다.)

#### 왜 분리가 필요한가?   
많은 고수준 언어와 많은 프로세서와 명령어 집합의 종류에 따라 더 많은 컴파일러가 필요하고, 이런 컴파일러는 언어와 프로세서에 종속적이다.   

가상머신을 사용하면 기존의 컴파일러를 더 단순한 2개의 프로그램으로 분리한다.

고수준 언어를 중간 언어로 번역하는 VM 컴파일러(front-end)와 중간 언어를 기계어로 번역하는 VM 인터프리터(back-end)를 사용한다. 

이러한 추상화를 통해,   
제조사는 중간 언어만 담당하는 VM(런타임 시스템)을 상대적으로 쉽게 구현할 수 있고,   
고수준 언어는 중간 언어를 통해 여러 플랫폼을 지원하고 플랫폼 간 이식성을 부여할 수 있다.  
(또한, 구현 및 유지 관리 작업을 단순화 할 수 있다.)

#### 장/단점

장점으로는 위에서 말한 추상화를 통해 플랫폼 간 이식성이 높다는 것이다.

단점으로는 중간 과정이 추가되었으므로 1단계 컴파일러에 비해 속도가 느리다는 것이다. (VM을 사용하는 방식을 2단계 컴파일 모델 이라고 한다.)

## 런타임 시스템
모든 컴퓨터 시스템은 프로그램이 실행되는 환경을 제공하는 특정한 형태의 런타임 시스템이 있어야 한다.  
애플리케이션 메모리 관리, 프로그램이 변수에 액세스하는 방법, 함수 간 매개변수 전달 메커니즘, 운영 체제와의 인터페이스 등을 포함한 다양한 문제를 담당한다.

VM을 사용하는 경우, VM은 이러한 런타임 시스템의 일부이다. (JRE를 생각해보면, JVM외에도 클래스 로더나 기본 API 등 여러 요소가 있다.)     
(C언어의 경우 컴파일러가 실행 가능한 파일 이미지에 특정 명령 세트가 런타임 시스템이다.) 

자세한 내용은 [위키피디아의 런타임 시스템 항목](https://en.wikipedia.org/wiki/Runtime_system)을 참고하는 게 좋을 것 같다. 

## 스택 머신

스택 머신은 스택 기반(stack-based)의 VM을 의미한다. (레지스터 VM에 대한 이야기는 위 _주의점_ 참고)

#### 왜 스택 머신인가?

중간 언어는 컴파일러와 인터프리터 중 하나가 과도한 책임을 가지지 않도록 해야 한다. 적당히 고수준이면서 저수준이여야 한다. (기계어 내지 실행되는 환경에 종속적이면 안 된다.)

이 조건을 달성하기에 스택 머신이라는 추상적인 아키텍처를 VM 언어의 기반으로 삼는다.

#### push와 pop
스택 머신은 이름처럼 stack 자료구조가 핵심이다. 즉, push와 pop으로 모든 연산을 수행한다.

### 핵심 개념

#### 스택 - push와 pop
스택 머신은 이름처럼 stack 자료구조가 핵심이다. 즉, push와 pop으로 모든 연산을 수행한다.

#### 가상 메모리 세그먼트 
구체적인 실행 환경에 의존하지 않기 위해 메모리를 직접 접근하지 않아야 한다. 

구체적인 메모리 접근은 벡엔드 단계(인터프리터)에서 담당하고, VM은 신경쓰지 않는다.

VM은 `static 0`, `local 3` 같이 가상 메모리 세그먼트 내 항목들로 표현한다.

(JVM은 바이트코드를 보면 `#0`, `#1` 등으로 표현한다.)

### 스택 기반 연산

기초적인 산술 연산과 고수준 언어에서 사용하는 고수준 연산를 위해 분기, 함수 연산 기능이 필요하다.

#### 산술 연산

피연산자 x,y와 연산자 op가 있을 때, 다음과 같은 방식으로 동작한다.

1. stack에서 x,y를 pop 한다. (미리 상단에 x,y가 들어있어야 한다.)
2. `x op y`를 수행한다.
3. 수행 결과를 stack에 push 한다.

#### 분기 연산 
분기는 조건에 따라 다른 경로를 따르도록 하는 제어 구조를 말한다.  
프로그래밍의 핵심 개념 중 하나로 유연성과 기능을 확장하는데 중요한 역할을 한다. 

VM의 분기(goto) 명령과 논리 명령을 사용해서 구현할 수 있다.

#### 함수 연산
함수는 재사용 가능한 미리 준비된 연산을 의미한다. 모듈형 프로그래밍의 가장 기본 기능이다.

함수는 산술/분기 연산과 달리 추가 연산이 필요하다.

"function call and return"에 대한 런타임 프러임워크를 구현하여 사용한다.

호출자(함수)와 피호출자(다른 함수)에 대한 정보를 포함해야 하므로 다음과 같은 추가 작업(overhead)를 처리해야 한다.

- 함수 호출 시
    1. 반환 주소 저장
    2. 호출자의 메모리 자원 저장
    3. 피호출자의 메모리 자원 할당
    4. 호출자가 전달한 인수를 피호출자 코드가 사용할 수 있도록 처리
    5. 피호출차의 코드 실행
- 함수 종료 시
    1. 피호출자의 반환 값을 호출자 코드가 사용할 수 있게 처리
    2. 피호출자의 메모리 자원을 반납
    3. 이전에 저장한 호출자의 메모리 자원을 복원
    4. 이전에 저장한 호출자의 반환 주소 복원
    5. 반환 주소부터 호출자의 코드를 이어서 실행

이러한 기능은 호출 스택(Call Stack)을 통해 구현된다.

호출 스택(Call Stack)은 호출된 함수의 상태를 관리한다.   
함수 호출 및 반환 주소를 추적한다. 함수가 호출될 때마다 새로운 프레임을 스택에 push, 함수가 반환될 때마다 해당 프레임을 pop한다.  
프레임(frame)은 함수에 대한 컨텍스트이다.

## VM의 역사

- 1970년대
    - 애플과 IBM이 개인용 컴퓨터 출시
    - 파스칼 언어가 유행하고 있었지만 회사마다 프로세서와 기계어, 운영체제가 달라서 다른 컴파일러가 필요했다.
    - 중간 p-code로 변환하고, p-code를 해석하는 컴파일러를 각 회사의 명령어에 맞게 구현함. 이는 초기 가상 머신 프레임워크였다.
- 1980년대
    - 2단계 컴파일 모델 언어인 파이썬. PVM을 사용한다.
- 1990년대 
    - 어느 기기, 또는 어느 운영체제 상에서도 실행될 수 있는 것을 목표로 하는 Java언어 발표. (선 마이크로시스템즈에서 개발, JVM이라는 가상머신 사용)
- 2000년대
    - 마이크로소프트는 .NET 프레임워크 출시. C#, C++ 등 여러 언어가 CLR(VM 프레임워크)에서 실행되는 중간 코드로 번역되고 실행될 수 있다.

## 실습
- VM 명령을 기계어로 바꾸는 VM 번역기(2단계 컴파일 모델에서 벡엔드 모듈)를 만든다.
- 구현 방식은 어셈블러와 동일하게 Parser(번역할 VM 명령어 찾기), CodeWriter(번역하기) 모듈로 구성된다.
- 7장에서는 산술 연산만을 지원하는 간단한 모델을 만들고, 8장에서 고수준 연산을 지원하는 완전한 VM 모델을 구현한다.

### 구현

가상머신 코드 변환기 구현에 있어서 중요한 건, 가상머신의 내부 동작에 대한 이해와 어셈블리어(책에선 hack 코드)에 대한 지식이 필요하다.

가상머신 코드 자체는 단순하고 스택만을 사용하지만, 실제로는 메모리 공간을 분리하고, 메모리를 직접 제어해야 한다.  

구현하면서 느낀 핵심 개념:
- 포인터: 포인터 개념을 사용해서 주로 사용하는 레지스터 주소에 이름을 붙이고, 거기에 다른 메모리 주로를 입력해서 구현한다.
- 메모리 영역: 각 스택 영역이 존재하는데, 각 영역별로 메모리를 분리해서 관리한다.
- 코드 작성 관련: 단순한 코드가 더 좋다. 파이썬 `file.write()`는 줄바꿈(`'\m''`)을 직접 적어줘야 한다. 중간에 테스트를 하자.
- 함수: 결국 거대한 스택 하나로 함수 호출을 관리함. Call Stack - (내 메모: Erlang 같은 일부 언어는 이런 내부 구조가 아니긴 한데, 대부분의 언어는 Call Stack을 사용함) 
  - 함수 호출 시 상태가 변경되므로 스택에 프레임(frame)이라는 이름의 데이터 집합에 caller 상태를 저장함. 이후 함수 리턴 시 해당 값을 사용하고, callee의 상태를 삭제함.(진짜로 데이터를 삭제하지는 않고, 스택 포인터 위치를 caller의 첫번째 인수 위치(리턴 결과 할당된)로 이동시켜주기만 하면 됨.)

내부 구현과 자세한 동작 원리는 책과 강의를 보는게 좋다.