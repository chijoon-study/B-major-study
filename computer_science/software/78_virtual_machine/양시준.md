# Virtual Machine

## 주의점

#### 1. 효율성 고려 X
다른 부분도 그렇듯, 이 책에서 다루는 가상머신에 대해선 효율성을 고려하지 않는다. 하지만 실제로는 정말 중요한 내용이다.   
> "실제로 Java, C#, Python의 VM 구현은 그동안 매우 극적으로 성능이 강화되고 정교해졌다."

#### 2. stack-based VM
스택 기반(stack-based)의 VM만 다룬다.  
대부분(Java, C#, Python 등)의 고수준 언어는 스택 기반의 VM를 사용한다. 

[레딧 글 - AskProggit: why are most VMs stack-based?](https://www.reddit.com/r/programming/comments/ap6wt/askproggit_why_are_most_vms_stackbased/)을 보면 레지스터 기반 VM은 스택 기반 VM보다 성능이 좋지만 기계어에 가깝고, 구현이 어렵다는 점 때문에 잘 사용하지 않는 것 같다.   
아예 사용하지 않는 건 아니다. Android의 Dalvik VM은 레지스터 기반 VM이다. (Dalvik VM은 Android 5.0 이상 버전부터 사용하지 않는다고 한다.)

#### 3. 7~8장 내용 포함
가상머신에 관한 내용은 7~8장으로 나누어 설명하는데, 이 글에선 두 장을 합쳐서 설명한다.

## 가상머신 패러다임

가상머신은 고수준 언어와 대상 기계어의 영역을 분리하는 중간 인터페이스이다. (추상화를 제공한다.)

#### 왜 분리가 필요한가?   
많은 고수준 언어와 많은 프로세서와 명령어 집합의 종류에 따라 더 많은 컴파일러가 필요하고, 이런 컴파일러는 언어와 프로세서에 종속적이다.   

가상머신을 사용하면 기존의 컴파일러를 더 단순한 2개의 프로그램으로 분리한다.

고수준 언어를 중간 언어로 번역하는 VM 컴파일러(front-end)와 중간 언어를 기계어로 번역하는 VM 인터프리터(back-end)를 사용한다. 

이러한 추상화를 통해,   
제조사는 중간 언어만 담당하는 VM(런타임 시스템)을 상대적으로 쉽게 구현할 수 있고,   
고수준 언어는 중간 언어를 통해 여러 플랫폼을 지원하고 플랫폼 간 이식성을 부여할 수 있다.  
(또한, 구현 및 유지 관리 작업을 단순화 할 수 있다.)

#### 장/단점

장점으로는 위에서 말한 추상화를 통해 플랫폼 간 이식성이 높다는 것이다.

단점으로는 중간 과정이 추가되었으므로 1단계 컴파일러에 비해 속도가 느리다는 것이다. (VM을 사용하는 방식을 2단계 컴파일 모델 이라고 한다.)

## 런타임 시스템
모든 컴퓨터 시스템은 프로그램이 실행되는 환경을 제공하는 특정한 형태의 런타임 시스템이 있어야 한다.  
애플리케이션 메모리 관리, 프로그램이 변수에 액세스하는 방법, 함수 간 매개변수 전달 메커니즘, 운영 체제와의 인터페이스 등을 포함한 다양한 문제를 담당한다.

VM을 사용하는 경우, VM은 이러한 런타임 시스템의 일부이다. (JRE를 생각해보면, JVM외에도 클래스 로더나 기본 API 등 여러 요소가 있다.)     
(C언어의 경우 컴파일러가 실행 가능한 파일 이미지에 특정 명령 세트가 런타임 시스템이다.) 

자세한 내용은 [위키피디아의 런타임 시스템 항목](https://en.wikipedia.org/wiki/Runtime_system)을 참고하는 게 좋을 것 같다. 

## 스택 머신

스택 머신은 스택 기반(stack-based)의 VM을 의미한다. (레지스터 VM에 대한 이야기는 위 _주의점_ 참고)

#### 왜 스택 머신인가?

중간 언어는 컴파일러와 인터프리터 중 하나가 과도한 책임을 가지지 않도록 해야 한다. 적당히 고수준이면서 저수준이여야 한다. (기계어 내지 실행되는 환경에 종속적이면 안 된다.)

이 조건을 달성하기에 스택 머신이라는 추상적인 아키텍처를 VM 언어의 기반으로 삼는다.

#### push와 pop
스택 머신은 이름처럼 stack 자료구조가 핵심이다. 즉, push와 pop으로 모든 연산을 수행한다.

### 핵심 개념

#### 스택 - push와 pop
스택 머신은 이름처럼 stack 자료구조가 핵심이다. 즉, push와 pop으로 모든 연산을 수행한다.

#### 가상 메모리 세그먼트 
구체적인 실행 환경에 의존하지 않기 위해 메모리를 직접 접근하지 않아야 한다. 

구체적인 메모리 접근은 벡엔드 단계(인터프리터)에서 담당하고, VM은 신경쓰지 않는다.

VM은 `static 0`, `local 3` 같이 가상 메모리 세그먼트 내 항목들로 표현한다.

(JVM은 바이트코드를 보면 `#0`, `#1` 등으로 표현한다.)

### 스택 기반 연산

기초적인 산술 연산과 고수준 언어에서 사용하는 고수준 연산를 위해 분기, 함수 연산 기능이 필요하다.

#### 산술 연산

피연산자 x,y와 연산자 op가 있을 때, 다음과 같은 방식으로 동작한다.

1. stack에서 x,y를 pop 한다. (미리 상단에 x,y가 들어있어야 한다.)
2. `x op y`를 수행한다.
3. 수행 결과를 stack에 push 한다.

#### 분기 연산 
분기는 조건에 따라 다른 경로를 따르도록 하는 제어 구조를 말한다.  
프로그래밍의 핵심 개념 중 하나로 유연성과 기능을 확장하는데 중요한 역할을 한다. 

VM의 분기(goto) 명령과 논리 명령을 사용해서 구현할 수 있다.

#### 함수 연산
함수는 재사용 가능한 미리 준비된 연산을 의미한다. 모듈형 프로그래밍의 가장 기본 기능이다.

함수는 산술/분기 연산과 달리 추가 연산이 필요하다.

"function call and return"에 대한 런타임 프러임워크를 구현하여 사용한다.

호출자(함수)와 피호출자(다른 함수)에 대한 정보를 포함해야 하므로 다음과 같은 추가 작업(overhead)를 처리해야 한다.

- 함수 호출 시
    1. 반환 주소 저장
    2. 호출자의 메모리 자원 저장
    3. 피호출자의 메모리 자원 할당
    4. 호출자가 전달한 인수를 피호출자 코드가 사용할 수 있도록 처리
    5. 피호출차의 코드 실행
- 함수 종료 시
    1. 피호출자의 반환 값을 호출자 코드가 사용할 수 있게 처리
    2. 피호출자의 메모리 자원을 반납
    3. 이전에 저장한 호출자의 메모리 자원을 복원
    4. 이전에 저장한 호출자의 반환 주소 복원
    5. 반환 주소부터 호출자의 코드를 이어서 실행

이러한 기능은 호출 스택(Call Stack)을 통해 구현된다.

호출 스택(Call Stack)은 호출된 함수의 상태를 관리한다.   
함수 호출 및 반환 주소를 추적한다. 함수가 호출될 때마다 새로운 프레임을 스택에 push, 함수가 반환될 때마다 해당 프레임을 pop한다.  
프레임(frame)은 함수에 대한 컨텍스트이다.

## VM의 역사

- 1970년대
    - 애플과 IBM이 개인용 컴퓨터 출시
    - 파스칼 언어가 유행하고 있었지만 회사마다 프로세서와 기계어, 운영체제가 달라서 다른 컴파일러가 필요했다.
    - 중간 p-code로 변환하고, p-code를 해석하는 컴파일러를 각 회사의 명령어에 맞게 구현함. 이는 초기 가상 머신 프레임워크였다.
- 1980년대
    - 2단계 컴파일 모델 언어인 파이썬. PVM을 사용한다.
- 1990년대 
    - 어느 기기, 또는 어느 운영체제 상에서도 실행될 수 있는 것을 목표로 하는 Java언어 발표. (선 마이크로시스템즈에서 개발, JVM이라는 가상머신 사용)
- 2000년대
    - 마이크로소프트는 .NET 프레임워크 출시. C#, C++ 등 여러 언어가 CLR(VM 프레임워크)에서 실행되는 중간 코드로 번역되고 실행될 수 있다.

## 실습
- VM 명령을 기계어로 바꾸는 VM 번역기(2단계 컴파일 모델에서 벡엔드 모듈)를 만든다.
- 구현 방식은 어셈블러와 동일하게 Parser(번역할 VM 명령어 찾기), CodeWriter(번역하기) 모듈로 구성된다.
- 7장에서는 산술 연산만을 지원하는 간단한 모델을 만들고, 8장에서 고수준 연산을 지원하는 완전한 VM 모델을 구현한다.

### 구현

가상머신 코드 변환기 구현에 있어서 중요한 건, 가상머신의 내부 동작에 대한 이해와 어셈블리어(책에선 hack 코드)에 대한 지식이 필요하다.

가상머신 코드 자체는 단순하고 스택만을 사용하지만, 실제로는 메모리 공간을 분리하고, 메모리를 직접 제어해야 한다.  

구현하면서 느낀 핵심 개념:
- 포인터: 포인터 개념을 사용해서 주로 사용하는 레지스터 주소에 이름을 붙이고, 거기에 다른 메모리 주로를 입력해서 구현한다.
- 메모리 영역: 각 스택 영역이 존재하는데, 각 영역별로 메모리를 분리해서 관리한다.
- 코드 작성 관련: 단순한 코드가 더 좋다. 파이썬 `file.write()`는 줄바꿈(`'\m''`)을 직접 적어줘야 한다. 중간에 테스트를 하자.

### 정리

VM 변환기 구현을 위해 알아야 할 것.
- 포인터: 메모리의 스택이나 할당된 공간에 다른 메모리 주소를 저장함. 그걸 스택 같은 부분에서 읽고 그 주소 값으로 이동함. 이게 포인터와 동일한 역할.  
- 메모리: 메모리를 각 영역으로 나누고 관리함. 포인터 개념에서 말했다시피 메모리 주소와 그 값에 다른 메모리 주소를 넣어놓은 이런 걸 이해할 수 있어야 함. 
- 어셈블리어(Hack): 가상머신의 동작을 어셈블리어로 변환할 수 있어야 함
  - 특히 jump같이 조건에 따라서 명령어 위치를 이동하는 것에 대한 지식도 필요함. 어셈블리어 입장에서 bool 연산도 여러 코드로 나눠지고, true/false 결과를 나타내기 위해 goto를 사용한다는 건 처음 알았음.
- 분기처리: 이거는 코드 좀 작성해보면 대충 알 정도만 알아도 되는듯. 
- 함수: 호출과 리턴 시 발생하는 메모리 상황에 대한 이해가 필요함. 
  - 정의: 재사용 가능한 코드 조각
    - 일종의 블랙박스 물체(artifact)이다. 약속된 인자를 제공하고 호출하면 특정한 값이 나온다.
    - 언어에서 제공하는 기본적인 연산(`+,-,*,/`)외에 기능을 구현할 때 사용할 수 있고, 무한히 확장 가능하다.
    - 여러 이름: subroutines, functions, procedures, methods 등 여러 이름이 있다. (여러 역사적인 이유료)
  - 호출: 
    - caller는 함수를 호출하기 위한 이름과 스택(arguments 전달용)이 필요하다. 
    - callee는 연산과 결과 리턴을 위한 스택, 연산 중간 결과 저장을 위한 로컬, 인수(arguments) 저장을 위한 arguments 공간까지 총 3가지 공간이 필요하다.
    - 그리고 이러한 공간은 논리적(물리는 상관없을듯?)으로 분리되어 있어야 한다.
    - 실제 구현에는 정확히는 위 공간 외에도 더 필요한데, 그건 구현된 VM변환기 코드 참고. (아니면 구현하고 정리하거니)
    - (내 생각) JVM 내부 동작 방식이랑 진짜 비슷하긴 함. 아마 주로 참고한 언어가 자바가 아닐까.
  - 상태:
    - 함수의 상태(state)란 함수를 호출했을 때 발생하는 논리적인 메모리 공간과 어떠한 정보를 의미한다.
    - 함수가 호출되고 종료되기 전까지 그 상태를 계속해서 유지해야 한다. 연쇄적으로 발생할 수 있고, 이러한 여러개의 상태 정보는 FIFO이므로 stack로 관리할 수 있다.
    - caller/callee는 각각의 상태를 가진다.
  - 리턴:
    - 결과를 caller의 arg 첫번째 위치에 저장하고, 스택 포인터를 해당 위치로 이동한다.
    - 기존의 작업들은 다른 작업들로 재정의되고, 스택 포인터가 변경되었으므로 삭제된 값으로 본다.


- 실제 함수 호출 시 필요한 내부적인 구현 - 이거 코드 부분으로 옮기기 
- 1부터 arg는 조금 애매할수도 있지만, callee의 블록이다.
  1. arg 포인터 저장(호출한 함수의 결과를 받는 곳이자, 호출 시 사용되는 인수의 시작점), stack에 저장됨
  2. caller의 상태 저장. frame이라고 부르는데, 메모리 segment(LCL, THAT 등), return address가 포함된다.
  3. 이제 callee의 메모리 segment(영역?)를 stack에 입력하고 stack을 사용해 연산
  4. 이후 결과를 arg 포인터에 저장하고, stack 포인터도 해당 위치로 이동. -> caller의 frame, callee가 사용한 영역들 전부 제거(실제로 제거된건 아니지만 어차피 덮어씌울거니까, CS에선 제거가 진짜 전부 지우는게 아닌 경우가 많다.)
