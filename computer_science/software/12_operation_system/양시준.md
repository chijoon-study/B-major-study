# Operating System

### 시작하기 전에 & 주의점

- 실제 OS와 책의 OS는 많이 다르다.
    - 멀티프로세스, 파일 시스템 추상화, 보안 등의 실제로 정말 중요한 (범용 컴퓨터에선 필수적인) 기능이지만 구현하지 않는다.
    - 프로젝트에서 나눗셈/곱셉 같은 기능이나 기하학 연산 등 OS에서 코드로 구현한 것들은 실제론 하드웨어의 도움을 받아 더 효율적으로 이루어진다.
        - CPU의 곱셉/나눗셈 명령어 or 그래픽 가속 하드웨어(주로 GPU에 포함) 등
- 프로젝트의 목적
    - 가장 핵심적인 OS의 목적(하드웨어 추상화 및 인터페이스 제공)을 제공하는 OS를 만드는 것.
- 개인적으로 항상 느끼는건, 이게 실제 예시로 설명하는게 아니다 보니. "프로젝트에 맞는 방식이고 실제로 사용하지 않는 (오래된) 방식이면 어쩌지?" 같은 생각이 든다.
    - 실제로도 본문에서 고전적인 방식이라고 하기도 하고... OS 관련 부분은 너무 주의깊게 볼 필요는 없을듯.
    - 많은 부분이 실제로 사용되는거 같긴 한데, 그래도 다르면 현대 범용 컴퓨터 기준으로 실제로는 어떤걸 사용하고 있는지 키워드라도 이야기해주면 좋지 않았을까?
        - 이번 장 메모리 관리만 해도 요즘 OS랑 많이 다르기도 하고
- 수학과 관련된 내용도 있는데, 이해 잘 안되도 넘겼다.

## 운영체제 (Operating System)

운영체제는 "하드웨어에 종속된 저수준 서비스를 프로그래머에게 친숙한 소프트웨어 서비스로 캡슐화해주는 프로그램" 정도로 볼 수 있다.        
사용자가 여러 프로세스나 하드웨어를 직접 관리하는 것은 비효율적이기 때문에 하드웨어와 소프트웨어 사이에 운영체제를 두어 하드웨어와 저수준 영역을 추상화한다.

운영체제가 제공하는 (내부적으로 하드웨어를 다루는) API를 사용해서 확장된 기능을 제공하는 프로그래밍 언어의 표준 API들이 많다.

실제 범용 컴퓨터의 운영체제는 그 외에 많은 기능(GUI, 파일 시스템, 외부 기기 I/O, 네트워크 등)을 제공한다. (실제 사용되는 OS에 대해선 다른 책을 읽어야 한다. 이 책은 리눅스 같은 실제 OS에 대해서
다루지 않는다.)

운영체제는 성능이 중요하다. 컴퓨터에서 실행되는 모든 프로그램에서 사용되기 때문이다. (프로그래밍 언어의 수학 연산, 메모리 관리 등 많은 부분은 내부적으로 운영체제의 API를 사용해서 구현한다.)

### 배경

앞서 말했듯, 운영체제는 성능이 중요하다.

그래서 효율적인 처리를 위해서 여러 알고리즘과 데이터구조를 사용한다.

실습에서 구현할 단순한 Jack OS의 구현에 필요한 배경 지식을 설명한다.

#### 수학 연산

(가능한 효율적인) O(n) 알고리즘을 사용해야 한다.

비트의 값이 아니라 비트 수에 비례해야 한다. 비트 값은 결국 비트의 수에 따라 증가하므로, 비트 수에 지수적으로 증가하는 값은 효율적이지 않다. (n비트 값 * 비트 수)    
그러므로 비트 수 n개에 비례하는 알고리즘을 사용한다. 이 비트 수 n은 데이터 타입에 따라 16, 32, 64 등 고정된 형태를 가진다.

- 곱셉
    - 2진수로도 일반적인 10진수의 곱셈처럼 수행할 수 있다. (x * y일때, y의 낮은 자리수부터 순차적으로 x를 곱하고 더하기) - 자세한 동작은 책을 보자. 구글링하거나.
    - 다른 방법으로도 곱셉을 구현할 수 있다. `x + x + x ... (y의 값만큼 반복)` 하지만 이는 y의 값에 의존적이므로 O(y) 시간 복잡도를 가진다. 그리고 y는 비트 수가 하나 늘어날 때마다
      2배의 범위를 가진다. 그래서 y의 값에 비례하는 이 방식은 비효율적이라 사용하지 않는다.
        - 16비트에서 32비트가 될 때, y에 비례하는 경우 2^16 -> 2^32 번 수행될 수 있지만(정확히는 아닐 수 있음, 증가 폭을 보기), 비트 수 n에 비례하면 수행 횟수는 2배만 증가한다.
- 나눗셈
    - 매 반복마다 x에서 y의 가장 큰 덩어리를 빼는 식으로 수행할 수 있다(장제법이라고도 함).
        - ex: `175/3` -> `(25 + 3*50)` -> `(1 + 3*8)`
- 제곱근
    - `x = √y`의 역함수 `x = y^2`를 사용해서 곱셉으로 구할 수 있다.

#### 문자열

문자는 그 자체로 저장하지 않고 약속된 2진 값을 저장하고 사용한다.

사용자에게 제공하는 경우에만 변환해서 약속된 문자로 보여준다.

이 변환 과정은 n길이의 문자열의 각 글자마다 수행하므로 O(n)이다

#### 메모리 관리

(현대 OS는 설명하는 방식이 아니라 가상 메모리 & 메모리 페이징 기법을 사용한다.)

필요에 따라 메모리를 할당하고, 반환해야 한다.

사용 가능한 메모리 세그면트들의 연결 리스트(freeList)를 사용한다.

메모리 할당 알고리즘으로 최적 적합 or 최초 적합을 사용할 수 있다.

사용 시 freeList에 제외하고, 사용이 끝나면 freeList에 기존의 사용했던 영역을 추가한다.

내부적으로 메모리만을 사용해서 이런 linked list를 구현할 수 있다. (값 일부를 포인터로 사용하기)

이 경우 메모리 단편화 문제가 발생할 수 있으므로 조각모음 연산을 고려해야 한다.

#### 그래픽 출력

Jack은 메모리 맵을 사용한다.

그래픽 구현에는 비트맵, 벡터 방식이 있다.

- 픽셀 그리기
    - 그리고자 하는 위치와 매핑되는 메모리 맵을 수정한다.
- 선/원 그리기
    - 스크린에서 두 점(픽셀) 사이에 연속적인 선을 그리려면, 실제로는 픽셀 그리드 위에 두 점 사이의 가상의 선을 가정하고, 이 선 위에 픽셀을 그려서 근사(가까운 값으로 대체)한다.
        - 이는 백터 그래픽을 그리는 방법이다. 비트맵 방식에서는 이미지를 픽셀 단위로 저장하므로, 이미지가 픽셀 그리드에 직접 매핑한다.
        - 가상의 선의 각도와 현재 그리고 있는 선의 각도의 차이(diff)를 구해서 다음 그릴 비트의 위치를 찾는다. 작성하려는 비트 수에 수행시간이 결정되므로 O(n)이다.
    - 원의 경우 곱셉, 제곱근, 선 기능을 사용해서 구현할 수 있다. (공식은 책 참고)

#### 키보드 입력

- 입력 감지: Jack은 메모리 맵 I/O를 사용하므로 메모리 맵의 변화가 있는지 계속 확인한다.
- 문자 읽기: 키가 눌렀다 떼어지는 한 동작을 처리한다.
- 문자열 읽기: 문자열의 끝(엔터)를 확인하고, 그 이전에는 백스페이스 등의 동작을 지원해야 한다.

#### 문자 출력

문자를 출력하기 위해서는 물리적인 픽셀 기반 스크린을 논리적인 문자 기반의 스크린으로 만들어야 한다.

- 글꼴: 글자를 표현하는 비트맵 이미지 집합
- 커서: 다음 문자가 그려질 위치를 기억하는 무언가를 "커서" 라고 부른다.

#### 배열

배열은 사실 운영체제보다는 컴파일러의가 신경써야 하는 거지만,    
Jack OS의 Array API에서는 심볼 테이블 없이 사용하기 위해 메모리를 명시적으로 할당(malloc)/해제 해 주어야 한다.

#### Sys

컴퓨터가 시작되고 운영체제를 시작하기 위해 부트스트래핑 과정이 필요하다.

이 부분은 여타 컴퓨터와 동일하게 하드웨어(BIOS ROM)에서 특정 코드를 호출한다. 여기에는 하드웨어 상태 확인 등 다양한 작업이 포함될 수 있다.     
문제가 없으면 운영체제를 찾아 부트 로더를 실행하고, 이로써 운영체제가 메모리에 로드된다.

Jack OS에서는 Sys가 이러한 운영체제의 시작점 역할을 한다.      
특정 (하드웨어) 설정 후 Sys.init()을 호출하면 Jack OS의 다양한 API의 초기화를 수행하고 Main.main()을 실행합니다.

그 외에 n초 대기, 에러 출력 등 기타 기능도 가지고 있다.

### 실습

앞서 설명한 배경 지식을 사용해서 Jack OS의 API를 구현한다. 8개의 클래스로 구성된다.

스텁 파일을 구현하고, 테스트 코드를 실행해서 잘 동작하는지 확인할 수 있다.

Jack OS는 현대적인 OS라고 보기는 어려울 수 있지만, 하드웨어 영역을 캡슐화해서 사용할 수 있도록 API를 제공한다는 점에서 OS의 핵심 목적을 어느정도 이루었다고 볼 수 있다.

#### 실습 하면서 남긴 메모

강의와 책에서 코드로 설명만 안했지 구현 방법에 대해서 거의 다 알려줘서 구현 자체는 쉽게 할 수 있었다. (강의가 좀 더 이해하기 쉬움)

값 수정은 운영체제 word 단위만큼 이루어져서 스크린의 하나의 비트를 수정하려면 기존 비트를 읽고, 특정 부분을 수정해서 다시 저장해야 한다.

선 그리기의 경우 방향, 수직/수평 등을 고려해야 한다.

