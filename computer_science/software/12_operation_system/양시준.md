# Operating System

### 시작하기 전에 & 주의점

- 실제 OS와 책의 OS는 많이 다르다.
    - 멀티프로세스, 파일 시스템 추상화, 보안 등의 실제로 정말 중요한 (범용 컴퓨터에선 필수적인) 기능이지만 구현하지 않는다.
    - 프로젝트에서 나눗셈/곱셉 같은 기능이나 기하학 연산 등 OS에서 코드로 구현한 것들은 실제론 하드웨어의 도움을 받아 더 효율적으로 이루어진다.
        - CPU의 곱셉/나눗셈 명령어 or 그래픽 가속 하드웨어(주로 GPU에 포함) 등
- 프로젝트의 목적
    - 가장 핵심적인 OS의 목적(하드웨어 추상화 및 인터페이스 제공)을 제공하는 OS를 만드는 것.
- 개인적으로 항상 느끼는건, 이게 실제 예시로 설명하는게 아니다 보니. "프로젝트에 맞는 방식이고 실제로 사용하지 않는 (오래된) 방식이면 어쩌지?" 같은 생각이 든다.
    - 실제로도 본문에서 고전적인 방식이라고 하기도 하고... OS 관련 부분은 너무 주의깊게 볼 필요는 없을듯.
    - 많은 부분이 실제로 사용되는거 같긴 한데, 그래도 다르면 현대 범용 컴퓨터 기준으로 실제로는 어떤걸 사용하고 있는지 키워드라도 이야기해주면 좋지 않았을까?
        - 이번 장 메모리 관리만 해도 요즘 OS랑 많이 다르기도 하고
- 수학과 관련된 내용도 있는데, 이해 잘 안되도 넘겼다.

## 운영체제 (Operating System)

운영체제는 "하드웨어에 종속된 저수준 서비스를 프로그래머에게 친숙한 소프트웨어 서비스로 캡슐화해주는 프로그램" 정도로 볼 수 있다.        
사용자가 여러 프로세스나 하드웨어를 직접 관리하는 것은 비효율적이기 때문에 하드웨어와 소프트웨어 사이에 운영체제를 두어 하드웨어와 저수준 영역을 추상화한다.

운영체제가 제공하는 (내부적으로 하드웨어를 다루는) API를 사용해서 확장된 기능을 제공하는 프로그래밍 언어의 표준 API들이 많다.

실제 범용 컴퓨터의 운영체제는 그 외에 많은 기능(GUI, 파일 시스템 등)을 제공한다. (실제 사용되는 OS에 대해선 다른 책을 읽어야 한다. 이 책은 리눅스 같은 OS에 대해서 다루지 않는다.)

운영체제는 성능이 중요하다. 컴퓨터에서 실행되는 모든 프로그램을 지원(관리)해야 하기 때문이다.

### 배경

앞서 말했듯, 운영체제는 성능이 중요하다.

그래서 효율적인 처리를 위해서 여러 알고리즘과 데이터구조를 사용한다.

실습에서 구현할 단순한 Jack OS의 구현에 필요한 배경 지식을 설명한다.

#### 수학 연산

(가능한 효율적인) O(n) 알고리즘을 사용해야 한다.

비트의 값이 아니라 비트 수에 비례해야 한다. 비트 값은 결국 비트의 수에 따라 증가하므로, 비트 수에 지수적으로 증가하는 값은 효율적이지 않다. (n비트 값 * 비트 수)    
그러므로 비트 수 n개에 비례하는 알고리즘을 사용한다. 이 비트 수 n은 데이터 타입에 따라 16, 32, 64 등 고정된 형태를 가진다.

- 곱셉
  - 2진수로도 일반적인 10진수의 곱셈처럼 수행할 수 있다. (x * y일때, y의 낮은 자리수부터 순차적으로 x를 곱하고 더하기) - 자세한 동작은 책을 보자. 구글링하거나.
- 나눗셈
  - 매 반복마다 x에서 y의 가장 큰 덩어리를 빼는 식으로 수행할 수 있다(장제법이라고도 함).
    - ex: `175/3` -> `(25 + 3*50)` -> `(1 + 3*8)` 
- 제곱근
  - `x = √y`의 역함수 `x = y^2`를 사용해서 곱셉으로 구할 수 있다.

#### 문자열

문자는 그 자체로 저장하지 않고 약속된 2진 값을 저장하고 사용한다.

사용자에게 제공하는 경우에만 변환해서 약속된 문자로 보여준다.

이 변환 과정은 n길이의 문자열의 각 글자마다 수행하므로 O(n)이다
    
#### 메모리 관리

(현대 OS는 설명하는 방식이 아니라 가상 메모리 & 메모리 페이징 기법을 사용한다.)

필요에 따라 메모리를 할당하고, 반환해야 한다.

사용 가능한 메모리 세그면트들의 연결 리스트를 사용한다.

메모리 할당 알고리즘으로 최적 적합 or 최초 적합을 사용할 수 있다. 

이 경우 메모리 단편화 문제가 발생할 수 있으므로 조각모음 연산을 고려해야 한다.

#### 그래픽 출력

Jack은 메모리 맵을 사용한다.

- 픽셀 그리기
  - 그리고자 하는 위치와 매핑되는 메모리 맵을 수정한다.
- 선/원 그리기
  - 스크린에서 두 점(픽셀) 사이에 연속적인 선을 그리려면, 실제로는 픽셀 그리드 위에 두 점 사이의 가상의 선을 가정하고, 이 선 위에 픽셀을 그려서 근사(가까운 값으로 대체)한다.
  - 원의 경우 곱셉, 제곱근, 선 기능을 사용해서 구현할 수 있다. (공식은 책 참고)

#### 문자 출력

문자를 출력하기 위해서는 물리적인 픽셀 기반 스크린을 논리적인 문자 기반의 스크린으로 만들어야 한다.

- 글꼴: 글자를 표현하는 비트맵 이미지 집합
- 커서: 다음 문자가 그려질 위치를 기억하는 무언가를 "커서" 라고 부른다.

#### 키보드 입력

- 입력 감지: Jack은 메모리 맵 I/O를 사용하므로 메모리 맵의 변화가 있는지 계속 확인한다.
- 문자 읽기: 키가 눌렀다 떼어지는 한 동작을 처리한다.
- 문자열 읽기: 문자열의 끝(엔터)를 확인하고, 그 이전에는 백스페이스 등의 동작을 지원해야 한다.

### 실습

앞서 설명한 배경 지식을 사용해서 Jack OS의 API를 구현한다. 8개의 클래스로 구성된다.

#### 실습 하면서 남긴 메모
