## 11장 스트림 처리

### 정리

- 일괄 처리(배치)의 문제점: 고정된 시간 단위, 너무 느리다.
- 스트림 처리: 스트림에서 이벤트가 발생할 때마다 처리한다. 일괄 처리보다 빠르다.
- 스트림의 의미: 시간 흐름에 따라 점진적으로 생산된 데이터. 유닉스나 프로그래밍 언어의 API 등에서도 동일한 의미로 쓰임.
- 이벤트의 의미: 특정 시점에 일어난 사건에 대한 세부사항을 포함하는 불변 데이터. (데이터가 아니라 어떤 사실을 의미하기도 함.)

#### 이벤트 스트림 전송

(여기 파트 너무 구체적으로 정리한듯...)

- 이벤트는 부호화되여 전송(네트워크), 관리(메모리, 디스크) 될 수 있다.
- 스트림 시스템에서는 관련 있는 이벤트를 토픽, 스트림 단위로 표현한다.
- 이러한 이벤트 스트림 처리에 특화된 메시징 시스템이 있다.
  - 파일이나 기존 데이터베이스(트리거)로도 충분히 가능하지만, 제한적이다.
  - 특정 토픽에 데이터를 추가하는 생산자, 토픽을 구독하고 데이터를 읽는 소비자로 역할이 나뉜다. (+ 소비자 그룹)

- **메시징 시스템**
  - 방식
    - (네트워크를 통해) 생산자에서 소비자로 직접 전달하기
      - UDP 멀티케스트, 웹훅, ZeroQM(TCP or IP 멀티케스트)
      - 생산자와 소비자가 각자 지속성 문제를 책임져야 한다.
        - 실패 복구 불가, 항상 온라인이여야 하는 문제가 있다.
    - 메시지 브로커 (전통적인 AMQP/JMS 방식)
      - 메시지 스트림 처리에 최적화된 데이터베이스의 일종.
        - 지속성 문제를 메시지 브로커가 처리한다. 생산자와 소비자는 클라이언트가 된다.
      - 소비자는 일반적으로 비동기로 동작한다. 
      - 소비자의 처리 속도가 느린 경우, 대처가 필요하다. (메시지 버리기, 버퍼링, 배압)
  - 메시지 브로커와 데이터베이스 비교
    - 데이터가 사용되면 삭제한다.
    - 작업 집합이 적다고 가정한다.
    - 보조 색인이나 데이터 검색 대신 토픽을 구독하는 방식.
    - 데이터 스냅숏을 제공하지 않는다. (읽기 시점 상태 보장 및 상태 변경 시 다른 작업 롤백 같은 처리 X)
  - 복수 소비자
    - 복수 소비자가 같은 토픽을 구독하는 경우, 어떻게 처리하는가?
    - 로드 밸런싱: 각 메시지는 소비자 중 하나로 전달. (1/N 같은 느낌)
    - 팬 아웃: 각 메시지가 모든 소비자에게 전달.
    - 두 전략을 함께 사용할 수 있다.
  - 확인 응답과 재전송
    - 소비자가 메시지를 처리한 경우 확인 응답을 받아서 메시지가 유실되지 않게 한다.
    - 부하 균형 분산과 결합된 재전송 행위는 메시지 순서가 바뀔 수 있다.
      - 메시지 간 인과성이 있는 경우 문제가 생긴다. (이후 내용에서 다룬다.)
- **파티셔닝 된 로그**
  - 로그 기반 메시지 브로커 시스템
    - 데이터베이스의 지속성과 메시징 시스템의 지연시간이 짦은 알림 기능을 혼합.
    - 생산자가 보낸 메시지를 파일의 끝에 쓰고, 소비자는 추가된 데이터를 읽는다.
    - 예시
      - 아파치 카프카, 아마존 키네시스 스트림
  - 토픽을 파티셔닝하여 파티션을 다른 파티션과 독립적으로 읽고 쓸 수 있다.
    - 파티션 내의 브로커는 모든 메시지에 오프셋이라는 단조 증가하는 식별자를 부여한다. (파티션 단위로 고유)  
  - 전통적인 메시지 방식과 비교 (생략, 이해 잘 안감)
    - 로그 기반은 순서 보장, 많은 처리량, 속도가 빠르다. 대신, 처리하는 비용이 비싸고, 메시지 단위로 효율적인 병렬처리가 어렵다.
  - 소비자 오프셋
    - 소비자는 오프셋을 가지고 있고, 메시지 브로커는 그 오프셋에 따라 응답을 보내주면 된다.
    - 어차피 데이터를 소비하지 않으니, 소비자가 응답을 처리했는지 확인 응답을 추척할 필요가 없다.
    - 소비자 노드에 장에가 발생한 경우, 소비자 그룹 내 다른 노드가 장애가 발생한 노드가 처리하던 파티션의 오프셋부터 처리한다.
      - 이 사이에 오프셋이 잘못된 경우 데이터가 2번 처리될 수 있다. (중복 처리 가능성 문제)
  - 디스크 공간 사용: 원형 버퍼를 사용해서 저장한다는 내용. 덮어씌워질 수 있음.
  - 소비자가 생산자를 따라갈 수 없을 때: 원형 버퍼를 사용하므로 버퍼링 방식 (저장해둘테니까 따라서 써)
  - 소비자 오프셋을 변경하여 이전 결과를 다시 읽을 수 있다. (개발, 테스트, 분석 등에서 유용)

#### 데이터베이스와 스트림

- 여기까지 왔으면 관점을 바꿀 수 있는데, 데이터베이스 또한 일종의 스트림으로 볼 수도 있다.
  - 즉, 데이터베이스는 스트림 데이터의 현재 상태 캐시(구체화된 뷰)다. (로그가 진실이다.)
  - 데이터베이스(디스크)보다 로그가 더 먼저 저장되고, 복구도 로그 기준으로 한다.

- **시스템 동기화 유지하기**
  - 데이터는 현실적인 문제 때문에 복사되어 관리한다.
  - 이를 위해서 이중 기록(어플리케이션에서 각 데이터 시스템에 쓴다.)을 할 수 있지만, 순서 보장, 원자적 커밋 보장이 불가능하다.
- **변경 데이터 캡처**
  - change data capture, CDC라고 한다.
  - 데이터베이스에서 발생하는 변화를 다른 데이터 시스템이 읽고 처리하는 것.
  - 구현 방법
    - 초기 스냅숏: 전체 로그 히스토리가 필요하지만 현실적으로 가지고 있지 않으므로 스냅숏을 사용함.
    - 로그 컴팩션: 로그 히스토리 중 현재 상태만 컴팩션해서 처리한다. (이벤트(변경) 발생 여부 자체가 중요한 경우 사용 불가능)
    - 변경 스트림용 API 지원: 최근 데이터베이스는 변경 스트림 API를 지원한다.
- **이벤트 소싱**
  - 이벤트 소싱
    - 어플리케이션 단의 이벤트를 저장하고, 그 이벤트를 다른 데이터 시스템이 읽고 처리하는 것.
    - CDC에 비해 더 고수준의 추상화 된 방식이다.
    - 데이터베이스보다 더 추상적이고 자유롭게 이벤트를 기록할 수 있다.
  - 이벤트 로그에서 현재 상태 파싱하기
    - 이벤트 소싱은 사용자의 행동 의도를 표현하므로 로그 컴팩션이 불가능하다. 
      - (깃 레포지토리나 쇼핑몰의 사용자 행동과 같은 것)
    - 상태를 재구축하기 위해선 모든 이벤트를 복사해야 한다.
  - 명령과 이벤트
    - 명령: 사용자의 요청, 검증을 통해서 거부 가능
    - 이벤트: 어떤 일의 사실, 영구적으로 저장되고 거부 불가능.
    - 결제 요청 이벤트, 결제 검증 이벤트와 같이 논리적으로 검증이 나중에 수행되도록 만들기도 함.
      - 이벤트 발생 사실 자체가 필요한 경우
- **상태와 스트림 그리고 불변셩**
  - 불변 이벤트의 장점
    - 금융 시스템을 예시로 드는데, 문제가 생기면 수정하지 않고 올바른 상태가 되도록 추가한다.
    - 불변 이벤트 로그의 경우 문제 상황의 진단과 복구가 쉽다.
    - 또한 여러 유용한 정보를 저장한다. (쇼핑몰의 사용자 정보 추적 등.)
    - (History 성 데이터의 필요성으로도 볼 수 있을 듯?)
  - 동일한 이벤트 로그로 여러 가지 뷰 만들기
    - 동일한 이벤트 로그로 필요에 따라 여러 가지 뷰를 만들 수 있다.
    - 예시
      - CQRS가 이해하기 쉬운 예시라고 생각하는데, 하나의 이벤트로 저장용 데이터베이스와 읽기용 데이터베이스에 각각 다른 뷰가 생긴다.
      - 트위터의 홈 타인라인 캐시도 비슷함.
  - 동시성 제어 - (이 부분 이해 잘 못했음)
    - 이벤트 소싱과 변경 데이터 캡처(CDC)는 비동기 식으로 이루어지며, 기록을 다시 읽었을 때, 반영되지 않은 상태를 볼 수 있다. (이 해결책은 예전 장에서 설명하므로 생략, 책 보기)
    - 반면 이벤트 로그는 현재 상태를 만들면 처리가 단순해진다. 이벤트를 로그로 저장하기만 하면 되서 적용하기도 쉽다. 
  - 불변성의 한계
    - 불현 히스토리를 유지하는게 어려울 수 있다. (전체 데이터 셋 크기와 무관하게 변경 데이터 셋의 정도에 따라서)
    - 이벤트 삭제가 불가능하거나 어렵다.
      - 제공하는 데이터 시스템도 있지만, 당장 Git만 생각해봐도 덮어씌우기가 아니라 중간을 제거하는 방법은 제공하지 않는다. (Git은 그냥 불변성의 이해를 돕기 위한 내가 쓴 예시)
      - 하지만 현실에선 법률적인 이유나 여러 이유로 삭제가 필요하다.

#### 스트림 처리

스트림으로 다른 파생 스트림을 생산하는 부분을 다룬다.   
이런 스트림을 처리하는 조각을 연산자(operator)나 작업(job)이라고 부른다. (배치, 맵리듀스 등에서도 비슷한 의므로 쓰인다.)

- **스트림 처리의 사용**
  - 복잡한 이벤트 처리(complex event processing, CEP)
    - 복수 이벤트로 구성된 패턴을 찾는다.
    - 질의는 저장되어, 입력 스트림으로부터 들어오는 이벤트는 질의를 통과하면서 매칭되는 이벤트를 찾는다.
      - 기존의 데이터베이스 시스템의 질의와 데이터의 관계와 반대다.
  - 스트림 분석
    - CEP와 달리 통계적 목적이 더 크다.
      - 빈도, 이동 평균, 비교 등.
    - 이를 위해 집계 시간 간격을 정의하는데, 이를 윈도우(window)라고 한다. (뭔가 SQL의 윈도우 함수와도 연관 있을거 같은 느낌?)
    - 스트림 분석 시스템은 확률적 알고리즘을 사용하기도 한다. (블룸 필터, 하이퍼로그로그)
  - 구체화 뷰 유지하기
    - CQRS나 캐시, 검색 색인, 데이터 웨어하우스 등에서 최신 상태를 유지하기 위해 사용될 수 있다.
  - 스트림 상에서 검색하기  
    - 필요에 따라 복잡한 조건으로 개별 이벤트를 검색하야 하는 경우가 있고, 이러한 검색 질의를 설정하여 꾸준히 매칭되는 이벤트를 찾을 수 있다.
      - (뉴스 구독과 같은 느낌? 내가 생각하는 검색이라는 느낌과는 약간 다르고, 조건 구독? 같은 느낌.)
  - 메시지 전달과 RPC - (이해 잘 안감)
    - 메시지 전달 시스템을 RPC 대안으로 사용할 수 있다.
- **시간에 관한 추론**
  - (분산 시스템이 늘 그렇듯 시간 처리는 어렵다. 특히 단조가 아니라 '지난 5분' 같은 범위의 경우)
  - 이벤트 시간 대 처리 시간
    - 이벤트 시간: 이벤트가 발생한 시간
      - 이벤트 발행 시점에 적지만, 이것 또한 NTP를 사용하므로 신뢰할 수 없다.
    - 처리 시간: 스트림 처리자가가 이벤트를 받은 시간
      - 재시작하거나 네트워크 등으로 딜레이가 생긴 경우, 이벤트 시간과 괴리가 생길 수 있다.
  - 준비 여부 인식(낙오자 이벤트 처리)
    - 특정 시간을 기준으로 처리하고 싶어도, 그 이벤트가 아직 전부 다 들어왔는지 확신할 수 없다. 즉, 낙오자가 발생한다.
    - 처리 방법
      - 무시한다. 낙오자 수가 일정 범위 이상이면 경고하는 등의 시스템이 필요하다.
      - 수정 값을 발행한다. 이전 출력을 취소하고 다시 실행해야 할 수도 있다.
  - 결국 어떤 시계를 사용할 것인가?
    - 결국 위에서 설명한 이벤트, 처리 시간을 신뢰할 수 없다.
    - 3가지 타임스탬프를 받아서 잘못된 시간을 조정할 수 았다.
      - 이벤트 발생 시간: 장치 시게
      - 이벤트 전송 시간: 장치 시게
      - 처리 시간: 서버 시계
  - 윈도우 유형 (생략)
    - 윈도우 기간을 어떻게 정의하는가에 대한 설명 (생략)
- **스트림 조인**
  - 설명: 일괄 처리와 마찬가지로 조인이 필요하다.
    - 공통적으로 조인 입력을 기반으로 한 특정 상태를 유지하고, 다른 조인 입력에서 온 메시지에 그 상태를 질의한다.
  - 스트림 스트림 조인(윈도우 조인): 
    - 두 입력 스트림은 활성 이벤트이다.
    - 스트림은 무한하므로 윈도우(범위)가 필요하다.
    - e.g. 같은 사용자가 취한 행동 중 시간차가 30분 이내인 2개의 행동을 묶기(조인)
  - 스트림 테이블 조인(스트림 강화): 
    - 한 입력 스트림은 활동 이벤트고, 다른 스트림은 데이터베이스의 변경 로그이다.
    - 원격 조인의 경우 느리기 때문에 데이터베이스의 사본을 로컬에 저장하고 CDC를 사용해 최근 상태를 유지한다. (경우에 따라 원격 조인도 가능)
    - e.g. 활동 이벤트에서 사용자의 프로필 정보를 추가(강화)
  - 테이블 테이블 조인(구체화 뷰 유지):
    - 두 입력 스트림이 모두 데이터베이스의 변경 로그다.
    - 한 쪽의 변경을 다른 쪽의 최신 상태와 조인한다.
    - 조인 결과는 두 테이블을 조인한 구체화 뷰와 변경 스트림이 된다. << (이해 안감)
    - e.g. 트위터 타임라인의 구현.
      - 트윗 이벤트 스트림과 팔로우 관계 이벤트 스트림의 조인이 필요하다.
      - 트윗이나 팔로우 관계의 변경 발생 시 타임라인 캐시(구체화 뷰) 또한 바뀌어야 한다.
  - 조인의 시간 의존성: << 이해 못했음. 나중에 다시 보기
    - 조인의 경우 상태를 유지해야 한다. 따라서 시간 의존성을 가진다.
    - 복수 개의 스트림에 걸친 이벤트 순서가 결정되지 않으면 조인도 비결정적이다.
    - 이러한 문제를 slowly changing dimenstion이라고 하는데,
    - (생략)
- **내결함성**
  - 설명: 스트림 처리에서도 내결함성 문제가 발생한다. 스트림은 무한하고 이러한 특징으로 인해서 내결함성을 위한 방법아 덜 직관적이다.
  - 마이크로 일괄 처리와 체크 포인트
    - 마이크로 일괄 처리: 스트림을 작은 단위의 블록으로 나누고 각 블록을 일괄 처리하는 방식.
    - 체크 포인트: 상태를 저장하는 체크 포인트를 저장하고, 중간에 실패하면 그 체크 포인트부터 재시작한다.
    - 한계: 외부로 전달된 처리는 여러 번 다시 전달 될 수 있다. 부수효과가 여러 번 발생한다.
  - 원자적 커밋 재검토
    - XA와 같은 전통적인 분산 트랜잭션에서 사용하는 환경보다 더 제한된 환경(메시지 브로커? 무슨 상태인지 이해 못함)에서는 원자적 커밋을 구현할 수 있다.
    - 이종 기술 간 트랜잭션을 포기하고 내부적으로 트랜잭션을 사용할 수도 있다.
  - 멱등성
    - 카프카가 사용하는 방식
    - 메시지에 영속적이고 단조 증가하는 오프셋을 사용해서 여러 번 전달되어도 연산이 한 번만 처리되도록 할 수 있다.
  - 실패 후에 상태 재검토하기
    - 윈도우 집계나 조인처럼 상태가 필요한 스트림 처리는 실패 후에도 해당 상태가 복구됨을 보장해야 한다. (이해 잘 못함)
    - 방법
      - 상태 복제(로컬 저장)
      - 원격 상태
      - 선택 기준은 데이터 셋의 크기나 네트워크 상태와 같은 기반 인프라의 성능 특성에 따라 달라질 수 있다.

### 느낀점

또 많이 정리한거 같기도 하고...

일단 배터리가 7퍼 밖에 없어서 집에가서 다시 흝어보고 적을 예정

이해 안가는거 찾아서 보고, 이해 안가면 만나서 이야기하기

그 CDC랑 로그가 진실이다? 이 부분 인상깊었음. 

