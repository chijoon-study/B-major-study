
### 03장. 저장소와 검색

- DB의 역할
    - 데이터 변경(저장/수정/삭제 등)
    - 데이터 조회(인덱스, 쿼리 등)

- 로그: 연속된 추가 전용(append-only) 레코드. (e.g. MySQL Redo Log)
- 인덱스(색인, index)
    - 기본 데이터의 읽기 속도를 빠르게 하기 위한 추가적인 구조
    - 기본 데이터를 기반으로(의존하는) 추가되는 정보이므로, 수정 속도를 늦춘다. 
        - 기본 데이터 변경 시, 인덱스도 변경되어야 하기 때문. (내 메모: 항상은 아닐 수 있음. RDB의 조건 인덱스나 인덱스 건 컬럼이 수정되지 않는 변경 작업의 경우 변경되지 않을 수 있음.)
- DB 예시
    - 1. 비트캐스트(인메모리 + 로그 쌓이는 식 + hash 인덱스)
        - 세그먼트 단위로 로그 + 컴팩션 수행 -> (내 매모: 이거 LSM TREE 동작 방식이랑 유사하네, 근데 그냥 DB 자체가 LSM TREE인 느낌.)
            - 책에서 후술하는데, 
    - DB 구현 시 주의점
        - 주로 예상 못한 상황의 대처, 복구
    - 추가 전용 로그는 I/O, 복구 면에서 유용하다. (내 메모: WAL 말하는건가? 이거 나중에 나오려나)

- LSM & SS Table
    - 주로 NoSQL에서 사용
    - Sorted String Table : 정렬된 문자열 테이블, 각 키는 한 세그먼트에 하나만 있어야 한다. (컴팩션 과정을 통해 한 세그먼트에 한 키를 보장)
    - Log-Structured Tree: SS Table과 Memtable을 사용해서 동작하는 Tree. 인덱스를 사용한다.
    - Memtable: In-Memory. 주로 Red-Black Tree. Memtable는 인메모리므로 복구용 로그를 디스크에 쓰고, Memtable DB에 반영되면 버림.
    - 저장 방법
        - Memtable -(특정 조건)-> Level-1 SS Table -(특정 조건 시, 병합+컴팩션(merge sort와 비슷))-> Level-N SS Table  
            - 크기 계층, 레벨 컴팩션
    - 조회 속도를 높이기 위해 메모리에 더 넒은 간격을 분리하는 sparse(희소) index를 사용해서 읽기 속도를 향상시킴.
    - 블룸필터를 사용해서 조회 속도를 높임.
    - 추천 영상
        - ByteByteGo: https://www.youtube.com/watch?v=I6jB0nM9SKU
        - 코맹탈출: https://www.youtube.com/watch?v=i_vmkaR1x-I

- B-Tree
    - 블록/페이지: 주로 4kb 크기의 저장하고 최소 I/O 단위.
    - 한 노드에 여러 노드의 범위를 가지는 Tree 형태의 자료구조
    - 모든 노드가 같은 level을 가지고, 넒은 범위를 낮은 level로 표현/조회 가능하므로 사용.
    - WAL(Write-Ahead Log)를 사용해 디스크에 반영하기 전, 변경사항을 미리 로그 형태로 빠르게 적어둠. 복구용으로 사용.

- (내 생각: LSM Tree, B-Tree 설명은 자료구조 그 자체보다는 NoSQL, RDBMS 에서 사용하는 것들의 특징이라고 보는게 좋을듯? WAL 등을 설명하는 것도 그렇고...)

- (내 생각: SQLP 공부하면서 나왔던게 꽤 많이 나오는 듯? )

- LSM Tree, B-Tree 비교
    - 읽기 속도, 쓰기 속도: (상대적으로) LSM 쓰기 빠름, 읽기 느림. B는 그 반대
    - 순차/랜덤 IO: LSM 순차 IO 위주 작업이라 효율적, B는 랜덤 IO
    - 저장 효율: LSM이 컴팩션이 되고, B Tree는 페이지 기반이라 공간 효율적이지 않아서, LSM이 효율적임. (절대적인 크기는 책에서 말하지 않음)
        - (내 메모: 내가 알고있는건 LSM이 중복이 있어서 크기가 더 크다고 알고 있음.)
        - (내 메모: 이 부분은 잘 모르겠네. 아마 추측해보면 데이터 크기에 따라서 다르지 않을까. 중복이 전체 데이터에 큰 영향을 주지 않을 정도로 컴팩션이 많이 되고, 데이터가 크면 LSM이 효율적이게 될 수도 있을 것 같음. 물론 그 정도면 정규화되지 않은 NoSQL의 데이터들이 더 커서 전체적으로 보면 RDB가 공간을 덜 차지할 수도 있을 것 같고...)

- LSM Tree, B-Tree 따로 내가 정리했던거
    - https://github.com/YangSiJun528/memory/blob/master/notes/series/cs_bookmark/DataBase%20-%20RDB,%20NoSQL,%20index%20%EB%93%B1.md

- 기타 인덱스 + 관련 설명
    - 기본키 인덱스
    - 보조(secondary) 인덱스
    - 클러스터드 인덱스
    - 커버링 인덱스 (내 메모: 이건 인덱스라기보다는 인덱스만 사용해서 읽는 거 아닌가?)
    - 다중 컬럼 인덱스
        - 결합 인덱스: 내가 아는 일반적인 컬럼 여러개 사용하는 인덱스. 대신 후위 조건만 있으면 (거의 모든 상황에서) 무의미함.
        - 이런 문제를 해결하기 위한 2차원 인덱스를 사용한다고 함.
    - 전문 검색
        - 퍼지(fuzzy, 애매한) 쿼리 지원
        - 리버스 인덱스
    - 인메모리 DB

- OLTP, OLAP
    - OLTP(온라인 트랜잭션 프로세싱)
        - 일반 사용자들에게 제공 목적
        - 로우 지향 방식: 로우끼리 인접(연속되게)하게 저장하고, 읽는 것도 로우(행)단위
    - OLAP(온라인 분석 프로세싱)
        - 데이터 웨어하우스, 분석 용도
        - snowflake schema: fact_table을 기반으로 여러 분석용 table(을 기반으로 하는 다른 table)이 있는 모습 
        - 컬럼 지향 방식을 사용하기도 함.
            - 적은 칼럼을 조건으로 대용량의 데이터를 분석하는 특징이 있음.
            - 관계형 데이터를 컬럼끼리 인접(연속되게)하게 저장하고, 읽는 것도 컬럼(열)단위
        - 비트맵 부호화, 인덱스 사용 (내 메모: 이거 이해를 못했음.)
    - 서로 다른 목적, 최적화 방법, 다른 사용 기술

- 컬럼 지향 저장소 & 데이터 집계 관련 
    - 컬럼끼리 인접(연속되게)하게 저장하고, 읽는 것도 컬럼(열)단위
    - 딱히 지금 필요한 건 아니라 대충 보고 넘김

- 핵심 이야기
    - OLTP, OLAP
        - 사용 목적, 특징, 부하 지점, 최적화 지점, 내부 구조(로우, 컬럼 지향)
    - LSM Tree, B Tree
        - 특징: 로그 방식(추가와 가끔 삭제) or 추가, 수정, 삭제, 순차 or 랜덤 I/O 등


- 느낀점
    - DB가 어떻게 검색(인덱스)을 구현하는지 주로 다름. LSM, B Tree나 자료구조 자체라기보다는 DB에서 어떻게 사용되는가?
    - 생각보다 느낀점이 없음...
    - LSM Tree가 저장공간이 더 적다는 건 처음 들어보는거라 찾아보고 공유하면 좋을듯?
        - 내가 잘못 이해함. 책을 다시 읽어보니까. 저장소 오버헤드가 적다는 거였음. 
        - 절대적인 크기는 책에서 따로 말을 안했는데, 당연히 중복이 생길 수 있는 LSM Tree가 더 크지 않을까?