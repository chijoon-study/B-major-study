### 8장 분산 시스템의 골칫거리

### 정리
이 장에서는 분산 환경에서 발생하는 여러 문제점을 다룬다.

[아무리 작은 확률이라도 잘못될 가능성이 있다면 잘못된다.](https://ko.wikipedia.org/wiki/%EB%AC%B4%ED%95%9C_%EC%9B%90%EC%88%AD%EC%9D%B4_%EC%A0%95%EB%A6%AC)

#### 결함과 부분 장애 - 분산/단일 시스템의 장애 차이

- 단일 시스템
  - 슈퍼 컴퓨터, 범용 컴퓨터 등
  - (좋은 소프트웨어가 설치된 기기는) 문제가 발생했을 떄, 결정적(이상화)이다.
    - 실패 or 성공
  - 따라서 동작을 예측할 수 있다.
- 분산 시스템
  - 클라우드 컴퓨팅 등
  - 비결정적이다.
    - 부분 장애(partial failure)가 생긴다.
  - 따라서 동작을 예측할 수 없다. 
    - 더 많은 부분이 연관되어 있을수록 실패 확률은 늘어난다.

#### 신뢰성 없는 네트워크

- 대부분의 인터넷은 주로 비동기 패킷 네트워크이다. 이는 신뢰성이 없다. 
  - 언제 받을지 알 수 없으며(누락, 딜레이), 전달 여부도 알 수 없다.
- 현실에는 많은 결함이 있다.
  - 인적오류, 라우터 병목, 클라우드 컴퓨팅의 물리 컴퓨터에 쏠리는 네트워크 부하(여러 가상 컴퓨터를 가진다. 네트워크 딜레이, 컨텍스트 스위칭 등에 영향을 줄 수 있다.)
- 자동 결함 감지 기능이 필요하다.
  - 문제있는 노드로부터 연락을 받을수도 있으나 이것만으로는 신뢰할 수 없다. (전달을 못할수도 있음.)
  - 따라서, **주기적**으로 **여러 번** 요청하여 확실하게 결함이 발생하였음을 알 수 있어야 한다.
- 타임아웃
  - 비동기 네트워크는 기약 없는 지연(unbounded delay)를 가지므로 적절한 타임아웃 시간을 예측할 수 없다.
  - 따라서, 테스트를 통해서 적절한 타임아웃 시간을 정해야 한다.
- 네트워크 혼잡
  - 패킷 통신 기기는 출력/입력 큐가 있다. 
    - 각 디바이스(끝단) 뿐만 아니라 스위치나 라우터에도 병목이 생기거나 큐가 부족해서 패킷 손실이 발생할 수 있다.
  - 따라서, 이러한 혼잡 상황을 고려해서 장애 감지와 이른 타임아웃 위험성의 trade-off를 고려해서 적절한 시간을 선택해야 한다.
    - 네트워크 변동성(jitter)를 측정하고 자동으로 타임아웃 시간을 설정하는 도구를 사용하는 것도 좋다.
      - (TCP도 이런 식으로 동작한다는데, 나중에 공부할 때 찾아보면 좋을듯)
- (TIP) TCP와 UDP 중 선택 기준
  - 신뢰성과 헤더 크기의 차이 등 (차이 내용은 생략)
  - UDP: 지연된 데이터의 가치가 없는 상황
    - 실시간 스트리밍, 전화(VoIP)
- 동기 네트워크 vs 비동기 네트워크
  - 동기(회선 방식)
    - 고정된 양의 대역폭이 할당된다.
    - 지속적인 데이터 전송이 발생하지 않으면 낭비가 크다. - 주로 전화(ISDN)가 여기 해당됨.
    - 큐 대기가 없으므로 네트워크 종단 시간의 최대치가 고정되어 있다. 기약 있는 지연(bounded delay)
  - 비동기(패킷, 가상회선 방식)
    - 인터넷에서 일반적으로 쓰는 방식
    - 순간적으로 몰리는 트래픽에 최적화 되어있다.
    - 큐 대기로 인해서 기약 없는 지연(unbounded delay)을 가진다.

#### 신뢰성 없는 시계

- 단조 시계 vs 일 기준 시계
  - 일 기준 시계
    - NTP (Network Time Protocol)로 동기화되는 시간 정보.
    - 로컬 입장에서, NTP 서버에 요청하여 네트워크를 통해 동기화하므로 로컬의 시간이 변화(앞당겨지거나 느려지거나)할 수 있다.
      - NTP 서버와 로컬 사이의 네트워크 딜레이로 인해서 실제 시간과 약간의 오차가 있을 수 있다.
    - 주로 epoch를 기준으로 삼는다. (그 외 별개의 다른 기준 시점을 사용하기도 한다.)
    - ([나무위키](https://namu.wiki/w/NTP), [위키피디아](https://en.wikipedia.org/wiki/Network_Time_Protocol))
  - 단조 시계
    - 단조(단조로운 할때 그 단조) 시계는 로컬 시스템에서 가지고 있으며 시간이 변화하지 않고 항상 앞으로 일정하게 흐른다.
    - 따라서, 지속 시간(시간 구간)을 재는데 유용하다.
    - 주로 마이크로초나 그 이하 단위로 측정 가능하다.
    - 각 시스템에 각자 존재하므로, 다른 기기 or 하드웨어(CPU 등) 사이의 단조 시계 값은 비교하는게 의미 없다.
      - OS는 여러 CPU에 걸쳐 스케줄링 되더라도 단조적으로 보이게 보장하나, (정말 정확해야 하는 경우) 신뢰할 수는 없다.
  - [GPT 질문 결과 - 질문 내용은 나무위키 긁음](https://chatgpt.com/share/4c79980a-5af8-4d46-b46b-cf907b45873e)

- NTP를 통한 시계 동기화는 정확하지 않다.
  - NTP 서버와의 문제: 네트워크 지연, NTP 서버 이상, 방화벽 등
  - 로컬의 문제: 드리프트(로컬 수정 시계의 오차로 인한 gap), 동기화 시 조정으로 인한 시간 변화 등
  - 더 정확한 동기화를 위해선 GPT 수신기, PTP, 꾸준한 모니터링과 배포 등이 요구된다.

여기서부터 TODO

- 동기화된 시계에 의존하기
  - 대충 일 기준 시계의 문제점
  - 해결하기 위해 분산 노드간의 시간 비교, 일 기준 시간 대신 논리적 시계 (sequence 값) 사용

- 시계 읽기의 신뢰 구간
  - 그 네트워크? 드래프트? 범위를 포함하는 식으로 하면 보장 가능 << 이것도 위 해결방법중 하나

- 프로세스 중단
  - 프로세스 중단 시 시간 문제와 해결법
    - 쓰레드, 가상환경, GC 등에서 중단 가능
  - 응답 시간 보장: 리얼 타임 OS(데드라인 보장, 대신 전체적인 속도 느릴 수 있음. 경제적이지 않음)



#### 지식, 진실 그리고 거짓말



### 후기 - 내용 다듬기

클라우드 환경이 가상 컴퓨터라서, 내가 점유하지 않는 다른 가상 컴퓨터에서 물리적 컴퓨터의 네트워크 혼잡을 이끌어내서, 내가 병목이 생길수도 있다는게 되게 생각 못해봤던 포인트였음.

