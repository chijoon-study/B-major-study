### 9장 일관성과 합의

임시로 정리하고 다듬어야 할 듯.

내용이 생소한게 많아서 좀 이해하기 어렵다. 2장 마무리하면서 지금까지 다뤘던 내용이 이곳 저곳에 들어가있다...

##### 정리

- 선형셩
  - 가장 강한 일관성 모델
  - > 복제된 데이터가 오직 하나의 복사본만 있는 것처럼 보이게 하고 데이터에 대한 모든 연산을 원자적으로 만드는 것. ...(생략)... (데이터페이스가 단일 스레드 프로그램의 변수처럼 동작하게 만들어준다.)
  - 대신 속도가 느리다. 특히 네트워크 지연 등...
- 인과성
  - 선형성보다 좀 더 약한 모델 - 그래서 성능도 좀 더 좋다.
  - 발생한 이벤트에 순서를 보장한다.
  - 즉, 쓰는 시점에는 순서를 알 수 없고, 나중에 전체적인 결과를 기반으로 순서를 파악할 수 있다.
    - 따라서 두 연산 사이에 순서를 알 수 없을 때도 있다.
      - 두 쓰기 요청 중 어느것이 먼저인지 모른다. 이 경우 최종 쓰기 승리(LWW) 등의 해결 방법이 필요하다.
      - 이러한 문제점으로 인해서 **"합의"**가 필요하다.
- 합의
  - 모든 노드가 특정 결정을 인식하고 결정을 되돌릴 수 없는 방법으로 동의하는 것. 
  - 분산 환경에서 발생하는 여러 문제는 "합의"를 구현하므로 해결할 수 있고, 한 문제만 해결된다면 다른 문제도 쉽게 해결할 수 있다. (선형성 구현 가능)
    - 선형셩 CAS 레지스터(분산 환경에서 key를 말한다.)
    - 원자적 트랜잭션
    - 전체 순서 브로드캐스트
    - 잠금과 임차권(리더 권한)
    - 멤버십/코디네이션 서비스
    - 유일성 제약 조건
  - 이는 단일 리더 노드로 구현할 수 있다.
  - 단일 리더 노드가 문제가 발생했을 때,
    - 차단 및 복구 대기 
    - 인위적인(사람의 개입으로) 새 노드 사용
    - 자동으로 새 리더 노드 선출 - 알고리즘
- 주키퍼 같은 도구는 멤버십/코디네이션 서비스를 위학하는 역할을 한다. (이해 잘 안감, 추가로 구글링하거나 찾아보기)

- 다중 리더 or 리더 없는 분산 시스템은 전체 합의를 제공할 수 없다.
  - 즉, 어플리케이션, 사용자 등이 선형성 없이 발생하는 여러 문제를 대응할 수 있어야 한다.
  - (아마 어림짐작하면 인과성을 이야기하는 것 같음. - 추가로 찾아보기)


---

위에는 책 대충 읽고 마지막 소제목 정리 부분 다듬은건데, 읽고 나니까 확실히 약간 이해는 갈거 같음.

위 내용 기반으로 더 구체적으로 정리하기

- 용어 정리
  - 레지스터: 분산 시스템에서 x로 표현, 데이터베이스의 개별 객체를 의미한다. 키, 로우, document 등.
  - 코디네이션(합의) 서비스: 주키퍼나 etcd 등이 해당되며, 전체 순서 브로드캐스트를 제공한다. 이를 통해서 선형성 저장소를 구현할 수 있다.
    - 그 외에 여러 유용한 기능을 제공한다. (CAS 연산, 리더 선출, 연산의 전체 순서화(아마 전체 순서 브로드캐스트?), 장애 감지, 변경 알림.)
      - 이 기능을 통해서 작업을 노드에 할당하거나 서비스 찾기 등의 기능을 구현할 수 있다.



- 내결함성을 구축하는 가장 좋은 방법은 유용한 보장을 해주는 **범용 추상화**에 의존하는 것임.
  - e.g. 트랜잭션
  - 분산 환경에서 발생하는 여러 문제의 내결함성을 가지는 추상화가 선형성, 최종적 일관성, 인과성 등임.

- 최종적 일관성(저자는 수렴이라는 용어가 더 좋다고 생각)
  - 너무 약한 보장. 이로 인해 그 제한을 인식하고 개발해야 함.

- 선형성(최신성 보장)
  - 가장 강한 일관성 모델 중 하나.
  - 데이터베이스의 복제본이 하나만 있는 것과 동일하게 동작함.
  - 개별 객체(레지스터)에 실행되는 읽기와 쓰기 순서 보장. 
    - 한 노드에서 쓴 값을 다른 노드에서 읽는다면 또 다른 노드에서는 그 이전 시점의 데이터를 읽지 말아야 한다. (+ 아마? CAS 연산을 제공해야 한다.)
    - 직렬성과 다르다! - 선형성은 트랜잭션(격리)과 별개의 개념으로, 이상현상을 보장해주지 못한다. (+ 여러 요청이 "동시적"일 수 있다. 네트워크 지연에 의한 순서 보장 X)

- 선형성이 유용한 경우
  - 잠금과 리더 선출
    - 이를 위해 코디네이션 서비스인 주키퍼나 etcd가 사용된다.
  - 제약 조건과 유일성 보장
    - 분산 환경에서 예약, 잔고, 재고 등의 제약조건을 지키기 위해 필요하다.
    - 단, 외래 키(유일성 보장, unique 조건 제외)나 속성 제약 조건(Enum, Range 제약)은 제외.
  - 채널 간 타이밍 의존성
    - 여러 서비스가 의존하는 분산 서비스에서 경쟁 조건이 발생할 수 있다. (공유 데이터에 대한 동시 접근 문제이므로, 아직 없는 데이터에 접근하는 것도 경쟁 조건이다.)
    - 다른 방법으로도 해결할 수 있으나, 선형성이 가장 직관적이다.

- 선형성 구현하기
  - 구현 가능성
    - 단일 리더 복제: 선형적일 수도 있음. (리더와 동기식 복제 노드에서만 읽는 경우)
    - 합의 알고리즘: 선형적임.
    - 다중 리더 복제: 비선형적.
    - 리더 없는 복제: 아마도 비선형적. (정의에 따라 된다고 볼 수 있으나, 없다고 보는게 안전하다.)

- 선형성의 비용
  - CAP는 도움이 안된다.
    - CAP: "선형성이 없는 애플리케이션은 네트워크 문제에 더 강인하다."는 정리.
    - 단, 하나의 일관성 모델(선형성)과 네트워크 분단만을 고려한다.
    - 실제로는 더 많은 모델과 분산 환경의 문제(노드 죽음, 네트워크 지연 등)가 있으므로, 현대에는 도움이 되지 않는다.
  - 선형성은 느리다.
    - 컴퓨터 밑바닥의 다중코어 CPU나 RAM 조차 선형성을 보장하지 않고, 캐시를 사용해 비동기적으로 동작한다.
    - 이는 성능을 위한 것으로 선형성을 보장하는 알고리즘은 항상 느리기 때문에, 성능을 위해서 선형성을 포기하기도 한다.

- 순서화 보장(+ 인과성)
  - 순서화는 인과성을 보장해준다.
  - 인과성은 선형성보다 조금 더 느슨한 일관성 모델이다.
  - 인과성은 "happens-before" 관계를 보장한다. 즉, 한 이벤트가 다른 이벤트의 원인이 될 수 있는 경우(인과 관계가 있는 연산), 그 순서가 보장된다. 그 외의 경우 보장하지 못한다.
  - 구현 방법
    - 일련번호나 타임스템프
    - 단, 단일 리더가 아닌 경우 인과성에 일관적이지 않다.
    - 이 문제를 해결하기 위해 램포트 타임스탬프를 사용할 수 있다.
    - 버전 백터는 전체 순서화를 제공하지 않지만, 램포트 타임스탬프는 보장한다.
    - 그러나 한계가 있는데, 당장 성공 여부를 확인할 수 없다. (이를 위해선 다른 노드를 전부 확인해야 하는데, 이러면 내결함성이 낮아진다.)

- 전체 순서 브로드캐스트
  - 램포트 타임스탬프보다 강력하다. 메시지 전달 시점에 순서가 확정된다.
  - 노드 사이에 메시지를 교환하는 프로토콜로 기술된다.
  - 비공식적으로 두 가지 안전성 속성을 항상 만족한다. (비동기적으로)
    - 1. 신뢰성 있는 전달(전송된 메시지는 모든 곳에 전달된다.)
    - 2. 전체 순서가 정해진 전달(메시지는 모두 같은 순서로 전달된다.)
  - 전체 순서 브로드캐스트를 사용해서 선형성 저장소를 만들 수 있다. (어떻게 되는지는 생략, 추가로 반대로 구현하는 것도 가능)

- 분산 트랜잭션과 합의 (요 장은 이해 안가는게 많음)
  - 합의: 모든 노드가 특정 결정을 인식하고 결정을 되돌릴 수 없는 방법으로 동의하는 것.
  - 원자적 커밋: 모든 노드가 트랜잭션에 결과에 동의하는 것.
  - 2PC(2 phase commit)
    - 원자적 커밋을 보장하는 방법 중 하나.
    - 코디네이터라는 서비스(각 노드의 어플리케이션에 라이브러리 형태로 존재하거나 별도 서비스(노드)로 존재함)가 있다.
    - 순서: 1. 코디네이터(모든 노드에 준비 요청) -> 2. 모든 노드(준비 완료 ok 응답) -> 3. 코디네이터(커밋 및 커밋 요청) -> 4. 모든 노드(확인 ok 응답 시 커밋, 하나라도 거부시 롤백)
      - 만약 3에서 모든 노드에 요청이 가지 않는다면 될때까지 대기해야만 한다. 이미 커밋되었으므로
      - 단, 코디네이터가 죽는 경우 모든 노드는 대기해야 한다.
    - 이론상으로 3PC라는 더 좋은 프로토콜이 있으나, 신뢰성 있는 네트워크 환경에서만 유효하므로 거의 쓰이지 않는다.
      - 2PC는 블로킹이나 3PC는 논블로킹임.

- 현실의 분산 트랜잭션
  - 성능이 낮아지고 운영상의 문제를 일으키므로 특정 서비스는 분산 트랜잭션을 구현하지 않기도 한다.
  - 종류
    - 데이터베이스 내부 트랜잭션: 데이터베이스 내부에서만 호환되면 되므로 사용하므로 특화된 기법 가능.
    - 이종 분산 트랜잭션: 여러 다른 서비스에서 호환되어야 하므로 더 어렵다.
      - 모든 시스템이 동일한 원자적 커밋 프로토콜을 사용할 수 있어야만 구현 가능하다.
  - XA 트랜잭션
    - 이종 기술에서 2PC를 구현하는 표준. 여러 서비스에서 지원한다. (현실에서는 프로세스에 로딩되는 단순 라이브러리다.)
    - 장애 대처가 중요한 이유
      - 트랜잭션은 잠금을 수반하며, 중간에 장애가 발생하면 스스로 복구하거나 인위적인 개입이 발생하기 전까지 잠금이 절대 풀리지 않는다. 
      - 현실적으론 복구가 불가능한 경우도 있다. 이 경우 원자성을 깨는 선택을 해야만 할 수도 있다.
    - (이 사이에 소주제 2~3개 더 있는데, 이해 잘 안가서 생략함.)

