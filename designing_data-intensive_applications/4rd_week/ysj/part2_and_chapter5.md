### 파트 2. 분산 데이터

#### 정리
- 분산환경의 필요성
  - 확장성
  - 내결함성/고가용성
  - 지연 시간

- 아키텍처
  - 공유 메모리 아키텍처: 수직 확장
  - 비공유 아키텍처: 수직 확장. 각 기기를 노드라고 함.

- 분산
  - 복제: 같은 데이터의 복사본
  - 파티셔닝(샤딩): 작은 단위로 나눠서 저장. 

#### 후기

없음.

### 5장 

#### 정리

- 복제
  - 복제란?: 네트워크로 연결 된 (물리적으로 떨어진) 여러 기기가 동일한 데이터를 가지는 것
  - 복제의 문제: 복제된 데이터의 "변경"을 처리하는 것
  - 주로 DB에서 사용되지만, DB 말고 상태를 저장하는 MQ나 Event Broker 등에서도 쓰인다.

- 복제 용도
  - 고가용성(내결함성)
  - 자연 시간
  - 확장성(읽기 처리량)

- 리더와 팔로워
  - 리더: 쓰기와 읽기 전부를 수행한다.
  - 팔로워: 읽기 작업만 수행할 수 있다.

- 동기 / 비동기 복제
  - 동기식: 데이터 일관성을 보장한다. 단, 속도가 느리고, 복제본이 차단(죽거나 네트워크가 끊기거나 등등) 되면 리더도 block 된다.
    - 복제본이 많아질수록 block 될 확률도 늘어난다.
  - 비동기식: 일관성을 보장할 수 없다. (최근 상태가 아닐 수 있다.) 단, block 없이 수행된다.
    - 대신 최종적으로 언젠가는 리더의 상태가 반영되도록 하는 "최종적 일관성"을 지키도록 한다. 
      - (이러한 일관성이 잘 지켜지는지 정량화 할 수 있는 모니터링 기능 또한 중요하다.)
    - 일반적으로 비동기식으로 많이 동작한다.
##### 단일 리더 복제

하나의 리더와 여러 개의 팔로워(replica라고도 부름)가 있다.

- 새로운 팔로워 설정: (설명 생략)

- 노드 중단 처리
  - 팔로워 노드(따라잡기): 중단 복구 이후, 누락된 리더의 작업을 따라잡으면 됨.
  - 리터 노드(장애 복구): 리더가 장애인 경우, 복구를 위해 (최신 상태에 가까운) 팔로워 중 하나를 리더로 올린다.
    - 이 경우 리더가 아니게 된 노드가 리더라고 착각하거나, 특정 값이 누락되는 문제가 생길 수 있다. 이러한 문제의 해결 방법은 DB나 운영팀의 능력에 달려있다.

- 복제 방법 - (이거는 생략할껄...)
  - 구문: SQL문 자체의 복제. 거의 안 씀.
  - 로그: RDB의 WAL이나 NoSQL의 로그(로그가 저장소의 주요 부분)를 넘긴다. 단, 노드 별로 버전 호환성을 지켜줘야 한다.
  - 논리적: 복제용 로그를 사용하는 것. 로그 복제 방식보다 자유롭다.
  - 트리거: DB의 트리거나 Stored Procedure 기능을 사용해 사용자가 직접 구현하는 것. 높은 유연성.

##### 복제 지연 문제

비동기식 복제의 경우 지연이 발생할 수 있다. 이 경우 여러 의도하지 않은 동작이 발생할 수 있다.

따라서 아래 행위를 보장해야 한다.

- 자신이 쓴 내용 읽기: 자신이 쓴 내용을 바로 볼 수 있어야 한다.
- 단조 읽기(monotonic read): 시간이 거꾸로 흐르는 듯하게 보이는 현상 방지
- 일관된 순서로 읽기: 여러 순서의 쓰기 작업이 순서대로 보여져야 한다. (1,2,3 이 사용자에게 3,2,1 처럼 보여지지 않아야 함)

(보장하는 방법에 대한 설명은 생략)

결론적으로, 비동기식이지만, 사용자에게 동기식으로 동작하는 것 처럼 보여야 한다.

원래는 트랜잭션이 이런 역할을 수행했지만, 많은 시스템들이 분산 환경을 지원하기 위해서 트랜잭션을 포기했다.

##### 다중 리더 복제

여러 개의 리더가 있는 복제, 하나의 리더에 접근 불가능해도 문제 없이 동작한다.

여러 데이터센터에 각 리더 노드가 있는 형태를 가진다. 

데이터센터: 대규모의 컴퓨터 시스템 및 관련 구성 요소를 직접하여 관리하는 시설. 예로 AWS의 가용 영역(Availability Zone, AZ)이 있다. 근데 책에서는 그냥 "데이터를 저장하는 기기" 정도로 볼 수 있을 듯

- 예시
  - 오프라인 작업, 협엽 작업 등
  - 둘 다 사용자의 기기에 로컬 데이터베이스가 있다. 이는 사용자의 기기가 하나의 데이터센터가 된다는 의미이다.

- 쓰기 충돌
  - 2개 이상의 리더에서 동시에 쓰기 작업이 발생하는 경우 쓰기 충돌이 발생한다.
    - 해결하는 방법은 여러가지가 있다.
      - 최신 데이터를 쓰기 (주로 시계열 데이터로 식별, 충돌 정보를 로그로 남기기도 함)
      - 두 작업 모두 합쳐서 쓰기
      - 충돌 회피하기
      - 사용자 정의 (커스텀)
    
- 복제 토폴로지
  - 복제가 이루어지는 통신 경로
  - 종류
    - 전체 연결
    - 별(트리)
    - 원형
  - 일반적인 네트워크 통신의 토폴로지와 비슷해서 장단점 설명은 생략. 단일 장애점(single point of failure, SPOF) 관점으로 보면 됨.

##### 리더 없는 복제

모든 노드가 쓰기와 읽기를 수행한다.

병렬로 여러 노드에 쓰기/읽기 작업을 수행하고, 특정 수의 노드에서 작업이 성공하면 작업이 완료된 것으로 간주한다.

여러 노드들은 서로 통신하면서 최종적 일관성을 보장한다. (어떻게 하는지는 생략)

###### 정족수(quorum)

분산 시스템에서 일관성을 보장하기 위한 메커니즘

정족수는 다음 공식을 가진다. 

- W + R > N
  - W: 쓰기 작업을 성공으로 간주하기 위해 필요한 노드의 수
  - R: 읽기 작업을 성공으로 간주하기 위해 필요한 노드의 수
  - N: 전체 노드의 수

- 느슨한 정족수
  - 응답 가능한 노드가 W나 R보다 적은 경우 정족수 구성의 N에 해당되지 않는 다른 노드에 쓰기 작업을 수행하는 것
  - 성능과 가용성을 높이기 위해서 사용한다. 단, 일관성 저하 등의 문제가 생긴다.

###### 동시 쓰기 감지/처리

**CS에서의 "동시"의 의미**: 실제 실행 시간과 상관 없이, 두 작업 중 어떤 작업이 먼저 실행되었는지 모르는 경우 (네트워크나 여러 문제가 있으므로). 이전 발생(happens-before)가 없는 경우.

- 이전 발생 관계(Happens-Before Relationship) 확인하기
  - 작업 간 의존성을 파악하기 위해서 버전 번호를 사용하는 예시
    - 요청 시 본인이 가지는 버전, 서버가 가지는 버전, 다른 클라이언트의 요청 시 오는 버전, 등을 비교하여 의존성을 파악하는 걸 보여준다.


해결 방법
- 동시 쓰기 버리기 - 최종 쓰기 승리(LLW)라고도 부름
  - 마지막으로 쓴 데이터만 쓴다.
- 동시에 쓴 값 병합
- 이전 발생 관계 파악하기(버전 백터)


#### 후기

- 결국 트레이드 오프 관계
  - 쓰기 성능 높이기는 다중 쓰기로 가능 -> 대신 충돌 문제를 감수해야 함.
