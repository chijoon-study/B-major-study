
- 누가 정리한 블로그 글 : https://catsbi.oopy.io/38b39243-d4ab-4e5d-8b45-713005420fe9
- 영어로 정리한 거: https://github.com/ResidentMario/designing-data-intensive-applications-notes/tree/master

# 데이터 중심 어플리케이션 설계

## 목차

- [Part 1] 데이터 시스템의 기초
    - 01장: 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
    - 02장: 데이터 모델과 질의 언어
    - 03장: 저장소와 검색
    - 04장: 부호화와 발전
- [Part 2] 분산 데이터
    - 05장: 복제
    - 06장: 파티셔닝
    - 07장: 트랜잭션
    - 08장: 분산 시스템의 골칫거리
    - 09장: 일관성과 합의
- [Part 3] 파생
    - 10장: 일괄 처리
    - 11장: 스트림 처리
    - 12장: 데이터 시스템의 미래


# 머리말

- 책의 목표: 데이터 시스템(DBMS, MQ 등)이 왜 이렇게 생겼고, 어떻게 동작하는지 알 수 있다. 데이터 중심으로 어플리케이션 설계를 할 수 있게 되는 것.
- 제목의 의미
    - 현대는 데이터 중심으로 어플리케이션을 설계한다.
        - e.g. TPS 몇, 어느 정도의 데이터를 저장하고, N시간에 M개의 데이터를 처리할 수 있는가?
        - 근데 아닌 적이 있긴 하나? ‘CPU 성능 K 짜리 프로그램’ 같은 말을 들어본적이 없는데, 저자가 말하기는 데이터 중심으로 설계하기 때문에 이렇게 했다고 함.
- “필요없는 확장성을 갖추기 위한 노력은 낭비고 유연하지 못한 설계 속에 갇힐 수 있다.” 서문 p.21
    - 공감함. 특히 고등학교에서 HelloGSM 개발할 때 많이 느낌.
    - 이후에 데이터 시스템의 장단점을 고려해서 다른 것도 사용할 줄 알아야 한다고 하긴 함. 이 의견도 동의함.

# 01장: 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

- 소제목 “데이터 시스템에 대한 생각” p.4~5 - 여러 데이터 시스템이 연결된 그림
    - 주로 백엔드 개발자에게 포함되는 내용이라 생각함.
    - 비즈니스 로직 개발 + 데이터 시스템을 잘 엮기 << 이 2가지로 백엔드 개발을 나타낼 수 있음.
    - 관련해서 든 생각: FE가 Full Stack이 되어가고 있다.
        - Next.js, Sveltekit 같은 Full Stack 프레임워크의 탄생, Supabase 등으로 간단한 CRUD 기능은 기존에 FE 스택으로 통함되어가고 있다고 생각함.
        - 이런 상황에서 백엔드 개발자의 중요한 역량은 위에서 말한 (비즈니스 로직 개발 + 데이터 시스템을 잘 엮기) 가 될 것이라고 봄. 특히 데이터 시스템 설계가 중요함.
- 소제목 “신뢰성은 얼마나 중요할까?” p.10
    - 신뢰성과 비용(리소스)는 trade-off 관계. 그럼에도 최소한의 신뢰성을 가질 책임이 있다.
        - 앞으로 토이 프로젝트에서도 이런거 고려하면 좋을 듯?
        - 개발 마인드? 적으로 좋은거 같음.
- 부제목 “확장성” 중 
    - 트위터의 예시 설명 p.11~13
        - 서비스에 맞는 부하 매개변수를 찾는게 중요하다.
            - 추상적으로 데이터 개수 정도만 생각했는데, 생각보다 더 구체적인 값이고, 구체적인 상황이였음.
                - 나는 동시 접속 사용자 수 같은 것만 생각했는데,
                - 특정 기능에서 특정 값(부하 매개변수)도 될 수 있음.
            - 책에 나온 트위터의 경우 트윗 작성 기능에서, 작성자의 팔로우 개수가 부하 매개변수였음.
    - 선두 차단(head-of-line-blocking)
        - HOLB는 TCP, HTTP 등에서도 나옴.
        - 그냥 병목이라고 볼 수도 있을 듯.
    - 실전 백분위 p.16 
        - 결국 응답 시간을 결정하는 건, 특정 병목 지점이다. 병목 지점은 항상 생길 수 밖에 없음.
        - 아마존은 백분위 99.9를 기준으로 개선함
            - 왜? 속도가 느리면 대부분 데이터가 많은 (중요한) 사용자라서
                - 이걸 생각을 못했음. 나는 단순히 네트워크 같은 외부적인 요소때문일거라 생각했는데,  (물론 서비스 특성에 따라 달라질 수 있겠지만,)
            - 결국 최적화와 비용은 trade-off 관계, 만약 내가 서비스를 개발한다면, p99.9는 아니더라도 99나 90 정도를 목표로 개선하는게 적당할 듯.
    - 소제목 “부하 대응 접근 방식” p.17
        - 결국 가성비(실용적) 이 중요함. scale out, scale up도 가성비 측면에서 고려해야 함.
        - stateless 한 자원은 scale out이 쉬움. 반대로 stateful 한 자원은 어렵다. 
        - 요즘 DB가 프로시저나 부하 큰 작업을 수행하지 않는 이유 중 하나. (유지보수 문제도 있음)
        - 그러나, stateful한 어플리케이션도 추상화 기능으로 증가하는 추세. 대표적인 예시가 AWS Aurora나 k8s라고 생각함.
    - 중간 제목 “유지보수성” p.18~p.22
        - 운영성: 운영 팀이 하는 일을 알 수 있었다. 
            - DevOps를 찾아보니까, 직군 이름이라기보단 문화라고 봐야 하는 듯. 개발팀과 운영팀의 협력 정도로 볼 수 있을 듯? 
                - DevOps 팀이 있거나, 운영/개발을 한 팀에서 하거나 등…
        - 단순성: 추상화는 어디에나 있다.
            - Nand2Tetris에서 컴퓨터 구현할때도 나온 추상화.
            - OS, 네트워크, 프로그래밍 언어 등 사실 상 거의 모든 기술이 추상화로 동작한다고 생각함. 프로그래밍 생태계 말고도…
        - 발전성: TDD와 애자일의 목표
            - 책에서는 TDD나 애자일이 자주 변화하는 환경에서 빠른 대응을 위한 방법론 정도로 본다.
                - 실제로는 너무 광범위하게 쓰이는 것 같다. “agile is dead” 강연에서도 나오는데, 그냥 방법론을 따르는 것은 아무 의미 없다.
                - 고등학교에서 HelloGSM 개발할 때, 애자일하게 한다고 했는데, 기능이 명확하고 고정된 프로젝트 특성 상, 오히려 폭포수 방식이 더 나았을 수도 있을듯?
                    - 실제로도 폭포수처럼 진행된 느낌도 없지 않아 있고?
                    - 질문: 고등학교에서 애들 프로젝트 하는거 보면 그런 느낌 있지 않음? 나가 봤을 때는 사실 자기들 하고싶은거 하는 느낌이라, 스타트업에서 피드백 받고 방향성 전환하는 그런 느낌은 볼 수 없었음.



다음 내용은 요약 같은 거라 말할만한 건 아님.
- 신뢰성
    - 하드웨어 오류: 하드웨어 단 오류. 정전, 물리적 파손 등. 요즘에 AWS 같은 곳에서 하는 것처럼 하드웨어 중복(RAID, CPU 여러 개) 등이 점점 대중화되는 추세
    - 소프트웨어 오류: 사용하는 소프트웨어에 대한 오류. 옵저버빌리티를 통한 지속적인 케어로 해결해야 함.
    - 인적 오류: 사람이 실수해서 발생하는 오류, 제일 빈번함.
    - 신뢰성과 비용(리소스)는 trade-off 관계. 그럼에도 최소한의 신뢰성을 가질 책임이 있다.

- 진짜 요약 (너무 길고, 저 정도로 정리할꺼면 걍 책 봐야지)
    - 요구사항: 기능적/비기능적(신뢰성, 확장성, 유지보수성이 여기 포함)
    - 신뢰성: 
        - 결함(문제), 장애(시스템 중지), (일부 결함에 대한) 내결함성
        - 오류의 종류: 하드웨어, 소프트웨어, 인적
    - 확장성
        - 부하와 성능 측정 기준이 필요함.
            - 부하: 부하 매개변수 (트위터의 경우 피드 추가 시 팔로우의 수)
            - 성능 측정 기준: (응답 시간, 처리량) 백분위
        - 팬아웃: 한 서비스 호출 시 내부적으로 호출되는 다른 서비스 개수
        - 개선 방법
            - 특정 목적 어플리케이션 도입
            - scale out, scale up
    - 유지보수성
        - 운용성: 운영팀이 고부가가치 작업을 가능한 구조
        - 단순성: 낮은 우발적 복잡도(구현 상의 복잡도) - 좋은 추상화로 해결 가능
        - 발전성: 빠른 변화/행동 가능성 - 에자일, TDD 등 

# 02장: 데이터 모델과 질의 언어


- 데이터 모델 p.27
    - > 데이터 모델(data model)은 데이터의 관계, 접근과 그 흐름에 필요한 처리 과정에 관한 추상화된 모형이다. 소프트웨어 개발과 유지, 보수의 기준이 되기 때문에 소프트웨어 공학의 중요한 이슈이다. << 위키피디아
    - “데이터를 저장하고 처리하는 추상화된 구조” 정도로 볼 수 있을 듯?
    - 개발자 입장에서 일반적인 의미: MQ나 RDBMS, DocumentDB 등…
    - 고수준 데이터 모델: 특정 서비스의 API, 비즈니스 로직을 반영한 데이터 구조 등. 예를 들어, RESTful API를 통해 제공되는 데이터 모델.
    - 저수준 데이터 모델: 바이트코드 저장 방법, 이진 데이터의 물리적 저장 및 송수신 방법 등. 예를 들어, 특정 파일 시스템의 블록 구조, 네트워크 프로토콜을 통해 전송되는 데이터 패킷의 형식 등.

- 소제목 ‘관계형 모델과 문서 모델’ p 28~30
    - 서로 비슷해지고 있다.
        - 일부 RDB는 XML이나 JSON 지원하고 있음, 검색도 가능하다. 
        - DocumentDB는 조인이나 참조(외래키 역할)이나, 일부 DB(MongoDB 등)의 경우 BASE(완화된 ACID, 뭔지 잘 모름)를 보장하는 트랜잭션 기능까지 제공한다.

- 임피던스 불일치 p.30
    - 책에서도 나오지만, ORM도 이런 임피던스 불일치 문제를 보완하기 위한 기술 중 하나

- 쓰기 스키마, 읽기 스키마 p.40
    - 이해 잘 돼서 적어봄.
    - 쓰기 스키마(schema-on-write): RDBMS, 스키마가 쓰는 시점에 고정. (이해를 위한 비유: 정적 언어 같은 느낌)
    - 읽기 스키마(schema-on-read): NoSQL, 스키마를 읽는 시점에 고정. (이해를 위한 비유: 동적 언어 같은 느낌)

- “애플리케이션 적합한 데이터 모델 선택하는 작업은 중요하다.” p.57
    - 저자의 생각이 잘 드러나는 부분이라 생각.
    - 내 생각: 동의하는데, 회사나 팀이라면 적합한 데이터 모델을 학습하는 노력이나 러닝커브도 고려해야 한다.
        - 그냥 관리형 서비스 + 대충 사용법 정도만 습득하면 별로 비용이 높을 것 같지는 않은데, 이후 문제 해결이 어려울 수 있을 듯.
        - 잘 모르겠네… 내가 너무 내부 구조 이해 같은거에 집착하는거 같기도 하고. 

- 요약
    - 현재도 잘 사용되는 (범용 데이터 저장) DB: 관계형, 문서, 그래프 - 문서, 그래프는 NoSQL
        - NoSQL은 RDB의 문제를 해결하기 위해 탄생 - 엄격한 스키마(임피던스 불일치 문제), 자유로운 데이터 모델 부족, 쓰기 위주 작업에 비효율적, 대규모 데이터셋 지원 부족(scale out 어려움) 
    - 각자 특화 영역이 다르고, 흉내낼 수 있다고 해도 가성비가 별로임.
    - 데이터 모델의 질의 언어(Query Languages): “~ 해 줘” -> 어플리케이션마다 여러 질의 언어가 있음. 어플리케이션 내부에서 알아서 최적화해서 접근 경로를 찾음. 내부 최적화 로직이 질의 언어에 영향을 주지 않으므로 기능 개선도 쉬움. 
        - SQL, 사이퍼, 스파클 등 - 사이퍼,스파클은 graphDB 용
    - 데이터 모델의 프레임워크: MongoDB 집계 파이프라인, 맵리듀스 등
    - 아래는 특징 표 정리

다음은 일반적인 목적을 이야기하는 것. 특정 구현은 다를 수 있음 주의.

|  이름 | N:M, 1:N 관계 지원 |  목적 | 특징 |  스키마 |
|---|---|---|---|---|
|  RDBMS | 중간 | 비즈니스 데이터 처리(트랜잭션/배치) | 정규화(무결성, 일관성 유지), 트랜잭션 지원, 분산 환경에서 어려움, 높은 제약(스키마 엄격성) | schema-on-write |
|  DocumentDB | 낮음 | 문서 형식으로 데이터 저장 | 높은 유연성, 반정형 데이터 처리에 적합, 변경 시 중복 데이터 처리 필요 | schema-on-read |
|  GraphDB | 높음 | edge와 vertex로 관계 위주의 데이터 저장 | 복잡한 관계와 네트워크 구조 표현에 적합 | schema-on-read |


아래는 읽으면서 대충 한 메모, 이해 안되는거 찾아본 기록도 있음.

- 네트워크 모델
    - 위에서 아래로 방향이 고정된 그래프(여러 관계를 가짐) 같은 식.
    - 문법 예시: https://chatgpt.com/share/b6b960f0-1403-4149-a0b4-e395323f0dec 
        - 직접 접근 경로를 코드를 작성하듯이 써야 해서 수정 작업 등에서 불편함이 많았다고 함
    - 구조
        - https://en.wikipedia.org/wiki/Network_model
        - https://mariadb.com/kb/en/understanding-the-network-database-model/
        - https://www.geeksforgeeks.org/difference-between-network-and-relational-data-model/


- MySQL - 마이SQL, PostgreSQL - 포스트그레스큐엘 -> 발음을 쉽게 하려고 그런 건지는 모르겠지만, 영어로 해주면 좋았을텐데…

- 맵 리듀스 처음에는 이해를 못했음. 다음 자료 참고해서 이해
    - 대충 map(분산 노드)에 각 요청을 보내서 방출하면 reduce에서 방출된 데이터를 가지고 처리하는 방식. 특정 구현체보다는 추상화된 기법? 모델 같은 거였음.
    - https://www.youtube.com/watch?v=cvhKoniK5Uo
    - https://www.geeksforgeeks.org/mapreduce-understanding-with-real-life-example/

- 그래프 형 DB?
    - 이름만 알고 있었는데, 보니까 신기…
    - 지금 토이프로젝트 계획중인데 그래프 DB 쓰기도 적절할듯?
    - 내 입장에서 필요하지 않아보이는 (필요한 나중에 찾아도 되는) 내용인데, 책에서 너무 길게 다루고 있어서 좀 그랬음….

- 트리플 그래프는 트래플이라는 그 3가지 관계를 사용하기 때문에 이름이 이렇고,
    - GPT 피셜은 종류에 따라 트리플 저장소는 그래프 데이터베이스(Graph Database)나 RDF 데이터베이스(RDF Database) 등으로 구현될 수 있다고 함.

- 시멘틱 웹/트리플 그래프 추가 조사
    - GPT 정리: https://chatgpt.com/share/deea1174-7a4f-45a8-96b1-54e6f16bb81c
    - https://ko.wikipedia.org/wiki/%EC%8B%9C%EB%A7%A8%ED%8B%B1_%EC%9B%B9
    - https://ko.wikipedia.org/wiki/%EC%9E%90%EC%9B%90_%EA%B8%B0%EC%88%A0_%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC



- 책 2장까지의 후기
    - 두고두고 필요할 때 보기 좋은 책인듯?
    - 관련있는 주제 처음 조사할 때 찾아보기 좋아보임.

