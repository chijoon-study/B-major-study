### 4장 부호화와 발전

### 정리
- 데이터 표현 방식
    - 인메모리 표현: struct, array, object 등. CPU에서 효율적으로 다루기 위해서 최적화한다. (주로 포인터 사용)
    - 바이트열 표현: 파일에 쓰거나 네트워크로 주고받기 위해 다른 프로세스가 이해할 수 있는 형태로 인메모리 표현을 변환한 것.

    
- 4장 제목의 의미
    - 부호화: 일반적으로 직렬화/역직렬화라고 부르는 개념. (책에서는 부호화/복호화 라고 부르는데, 다른 장에서 트랜잭션을 설명할 때 직렬화라는 개념이 나오기 때문임)
    - 발전: (송수신에서 사용하는 데이터의 생김새) 스키마는 서비스의 요구사항(기획, 시간, 기술 등)이 바뀜에 따라 변하게 되는데, 이러한 변경을 얼마나 잘 지원하는가? 를 “발전성”이라고 부른다.
- 발전성이 중요한 이유
    - 어플리케이션의 발전과 배포 빈도를 높일 수 있다.
        - 상하위 호환성이 높아지고(유지보수? 관리성? 쉬운 변경 난이도), 순회식 업그레이드(여러 버전의 스키마를 지원하므로)를 가능하게 한다.

- 호환성
    - 상위 호환성: 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.
    - 하위 호환성: 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.

- 부호화/복호화란?
    - 부호화: 데이터를 다른 위치로 옮기기 위해 인메모리 표현에서 바이트열(스트림?)으로 변환.
    - 복호화: 부호화 반대.
    - 데이터를 저장하는 것도 다른 곳으로 옮기는 것(저장해두고, 다른 서비스 or 미래의 본인이 사용하기 위함이므로)

- 부호화 종류
    - 프로그래밍 언어 종속: Java의 Serializable 같은 방식. 프로그래밍 언어에 종속되고 상하위 호환성이 별로이므로 임시적인 방법이나 제한된 경우 외에는 비추한다고 함.
    - 텍스트 형식: JSON, XML, CSV 같은 방식, 많은 사람들이 동의할 수 있는 범용적인 형식이므로 많이 사용함. 단, 데이터 타입 정의가 모호하므로 주의해야 함.
    - 이진 스키마 기반 형식: 스리프트, 프로토콜 버퍼(구글꺼), 아브로(아파키꺼, 하둡에서 쓰기 위해서 탄생)
        - Thrift, Protocol Buffers, Avro
        - 효율적인 표현 방식: 이진 데이터로 변환, 작은 용량을 가지기 위해 필드명 제거 등 여러 기법.
        - 대신 필드 명을 가지지 않으므로 필드 종류를 설명하는 스키마가 필요함. 또, 데이터를 사람이 읽기 위해서 복호화/부호화 필요함
            - 스리프트, 프로토콜 버퍼는 중간 스키마(필드 정보와 매핑)를 코드로 정의함.
            - 아브로는 읽기/쓰기 스키마를 DB, 네트워크, 파일 등에 관리하고 그때그때 알맞게 가져와서 씀.
        - (이 부분에서 데이터 표현 방식이나 호환성 지원 방법 등을 설명하는데, 사용하지 않는 상황에서 굳이? 싶어서 정리안하고 대충 넘김)

- 데이터플로(데이터를 다른 프로세스로 전달하는 추상적인 방법) 종류
    - 데이터베이스
        - 상하위 호환성 필요. 어플리케이션 단에서 호환성을 망가트리지 않게 주의. (예전 스키마 구조로 데이터를 쓰면서 기존 데이터 유실)
        - 정보를 저장하고 나중에 사용
    - 서비스(클라이언트/서버)
        - SOAP는 표준 명세. WEB 표준 잘 안지킴
        - REST는 설계 철학. WEB 표준 잘 지키는 편. 상호운용성이 높아 Open API에서 자주 사용.
        - RPC 네트워크를 통하므로 로컬에서 호출하는 것처럼 사용하더라도 여러 문제가 있을 수 있음. 현재는 테스트나 여러 지원이 REST 대비 부족한 편. 대신 빠르긴 함. gRPC, Avro RPC 등.
    - 비동기 메시징
        - 메시지 브로커 (or 메시지 큐)
            - 클라이언트/서버 방식과 달리 응답을 기다리지 않고, 데이터를 남기기만 하는 생산자(Producer)와 데이터를 읽고 처리하기만 하는 소비자(Consumer)가 있는 비동기 방식.
        - 분산 액터 프레임워크
            - Erlang 같이 비동기적으로 여러 Actor들이 Message를 사용해 비동기적으로 통신하는 형태를 이야기한다.
            - (Akka는 들어보기만 했는데, 이제 대충 뭔지는 알듯?)

- 데이터플로와 복호화
    - 데이터베이스: 기록 시 부호화, 읽을 때 복호화
    - 서비스: 요청 시 클라이언트 부호화 → 서버 복호화. 서버는 반대로
    - 비동기 메시징: 송신자가 부호화, 수신자가 복호화

- 정리
  - 데이터 부호화(스키마 표현법)에 여러 종류가 있는데, 어플리케이션의 발전성에 영향을 주므로 중요하다.
    - 그 외 파일 크기, 범용성 등도 부호화 종류마다 특화된 기능이 다르다. 

### 후기

- 인상깊은 문장
    - > … 이런 상황에서 사람들이 동의만 한다면 얼마나 읽기 쉽고 효율적인 형식인지는 대개 중요하지 않다. 무엇이든 다른 조직의 동의를 얻는 어려움은 대부분의 다른 문제보다 더 크다.
        - 그냥 경우에 따라서 성능과는 별개로 모두에게 적용하기 좋은 상황이 더 알맞다는 내용. 관련해서 아래 생각이 들었다.
            - 개발 생태계에서 JavaScript가 사용성이나 성능이 좋지 않다고 생각하지만, 웹 생태계에 알맞아서, 웹 관련 광범위한 기능을 제공하는 점.
            - 나는 FE는 잘 모르지만, React보다 Svelte가 더 좋지만, 넘어갈만큼 획기적으로 좋지 않아서 React를 사용한다고 들었다.

- 내가 겪었던 프로그래밍 언어 종속 부호화 경험
    - Java 환경의 Spring 모듈 개발에서 Java의 Serializable 기능을 사용한 경험이 있다.
        - [GAuth-spring-boot-starter 프로젝트 링크](https://github.com/YangSiJun528/GAuth-spring-boot-starter)
    - 왜 필요했는가?: 그 [AbstractAuthenticationToken](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/authentication/AbstractAuthenticationToken.html) 을 상속하는 별도의 인증 객체를 만들었어야 했는데, AbstractAuthenticationToken이 Serializable을 구현함.
        - 왜냐면 AbstractAuthenticationToken은 Session DB에 저장될 수 있어야 하니까.
    - 해결 방법: `serialVersionUID` 값을 직접 구현했는데, 그래서 상하위 호환성이 잘 지켜지지 않을 수 있다. 어차피 라이브러리 개발이라서, 버전 관리만 잘 하면 하위 호완성은 확실하게 지킬 수 있을 것 같은데(확장만 하면 됨), 하위 호환성은 잘 모르겠음.
    - 관련해서 보면 좋을 자료: [https://inpa.tistory.com/entry/JAVA-☕-직렬화Serializable-완벽-마스터하기](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A7%81%EB%A0%AC%ED%99%94Serializable-%EC%99%84%EB%B2%BD-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EA%B8%B0)
- Spring Framework에서 본 부호화 관련 이야기
    - Spring에서 Redis 객체를 저장하는 RedisTemplate을 지원하는데, 객체 부호화/복호화를 어떻게 할지 설정할 수 있는 선택지를 제공한다. - [공식문서 링크](https://docs.spring.io/spring-data/redis/reference/redis/template.html)
    - 별개의 이야기일 수도 있지만, 예전에 어떤 컨퍼런스나 유튜브 채널에서 자바 내장 직렬화 기능을 사용하면 호환성이 별로라서 json 방식이나 그런 별도 직렬화 방식을 사용하라고 했던 기억이 남.
    - 이렇게 사용하는 사람,팀마다 원하는 부호화/복호화 방식이 다르므로 프레임워크 단에서 높은 확장성을 제공하는 듯?

#### GPT 답변 - `serialVersionUID` 관련 질문

    네, 맞습니다. Java에서 `serialVersionUID` 값을 직접 설정하면 상하위 호환성이 잘 지켜지지 않을 수 있습니다. 이는 `serialVersionUID` 값이 클래스의 버전과 관련된 정보를 포함하고 있기 때문에, 클래스 구조나 필드가 변경되었을 때 이 값을 적절히 업데이트하지 않으면 직렬화된 객체를 역직렬화할 때 문제가 발생할 수 있기 때문입니다.
    
    ##### `serialVersionUID`를 직접 설정할 때 주의할 점
    
    1. **클래스 버전 관리**:
        - 클래스의 필드, 메서드, 접근 제어자 등이 변경될 때마다 `serialVersionUID` 값을 업데이트해야 합니다. 그렇지 않으면, 새로운 버전의 클래스가 직렬화된 이전 버전의 객체를 제대로 역직렬화하지 못할 수 있습니다.
    2. **정적 및 일시적 필드**:
        - `static` 필드나 `transient` 필드는 직렬화되지 않기 때문에, 이러한 필드의 변경은 `serialVersionUID` 값에 영향을 주지 않습니다. 따라서 이들 필드의 변경에는 `serialVersionUID` 값을 갱신할 필요가 없습니다.
    3. **기본값 설정**:
        - 초기 클래스 작성 시 `serialVersionUID` 값을 설정하고, 클래스 구조에 중대한 변경이 없는 한 이 값을 유지하는 것이 좋습니다. 이를 통해 클래스의 호환성을 유지할 수 있습니다.
    4. **자동 생성된 `serialVersionUID` 피하기**:
        - IDE에서 자동으로 생성된 `serialVersionUID` 값을 사용하는 대신, 명확한 이유가 없다면 수동으로 값을 설정하는 것이 좋습니다. 자동 생성된 값은 클래스 구조의 작은 변화에도 쉽게 변경될 수 있기 때문입니다.
    5. **테스트**:
        - 새로운 버전의 클래스에서 이전 버전의 직렬화된 객체를 역직렬화하는 테스트를 수행하여 호환성을 검증합니다. 문제가 발생하면 `serialVersionUID` 값을 업데이트하거나, 클래스 구조를 조정해야 합니다.
    6. **클래스 변경 정책 수립**:
        - 클래스의 변경 정책을 수립하고, 클래스 구조 변경 시 `serialVersionUID` 값을 어떻게 관리할지에 대한 명확한 가이드를 마련합니다.
    
    ##### `serialVersionUID` 설정 예시
    
    ```java
    public class ExampleClass implements Serializable {
        private static final long serialVersionUID = 1L;
    
        private int id;
        private String name;
    
        // getters and setters
    }
    
    ```
    
    위의 코드에서 `serialVersionUID` 값이 `1L`로 설정되어 있습니다. 클래스의 구조가 변경되면 이 값을 변경해야 합니다.
    
    ```java
    public class ExampleClass implements Serializable {
        private static final long serialVersionUID = 2L; // 구조 변경으로 인해 serialVersionUID 값 갱신
    
        private int id;
        private String name;
        private String address; // 새로운 필드 추가
    
        // getters and setters
    }
    
    ```
    
    이처럼, `serialVersionUID` 값을 적절히 관리하여 상하위 호환성을 유지하는 것이 중요합니다.